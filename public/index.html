<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShebaBingo - Premium Ethiopian Bingo</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#f1c40f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.5, user-scalable=yes, viewport-fit=cover">
    <meta name="telegram-web-app" content="sheba-bingo">
<script src="https://telegram.org/js/telegram-web-app.js"></script>   
    <!-- All CSS Styles -->
    <style>
        /* Modern International Bingo Color Scheme - Copyright Free */
       /* ===============================
   GEEZ BINGO STYLE ‚Äì TELEGRAM MINI-APP
   FIXED FULLSCREEN ‚Äì SIDE BY SIDE ALWAYS
   HIGH READABILITY ‚Äì ZERO WASTED SPACE
   =============================== */

:root {
    --bg-purple: #d7b9f7;
    --panel-purple: #c8a7ef;
    --deep-purple: #8b3de8;
    --orange: #ff9a3c;
    --green: #34d399;
    --red: #ef4444;
    --yellow: #facc15;
    --text-dark: #3a2c50;

    /* Keep your theme colors */
    --sunset-orange:#FF6B35; --safari-gold:#F7C46C;
    --savannah-green:#2E8B57; --ethiopian-blue:#1E3A8A;
    --desert-sand:#E8D2A6; --royal-purple:#6B46C1;
    --ivory-white:#FFF8F0; --charcoal-dark:#2D3748;
}

/* Global Reset */
*{margin:0;padding:0;box-sizing:border-box;font-family:'Poppins',sans-serif;}
html,body{height:100%;width:100%;overflow:hidden;position:fixed;  
    background: linear-gradient(135deg, var(--charcoal-dark) 0%, var(--marked-green) 100%);}

/* MAIN CONTAINER */
.game-container{
    width:100%;height:100vh;
    display:flex;flex-direction:column;
   background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px);
}

/* TOP NAV (minimized like GeezBingo) */
.top-nav{
    height:46px;
    display:flex;
    align-items:center;
    justify-content:space-between; /* This is CRITICAL */
    padding:4px 10px;
    background: linear-gradient(135deg, var(--charcoal-dark) 0%, var(--royal-purple) 50%, var(--savannah-green) 100%);
    color:var(--text-dark);
    border-bottom:3px solid #ccc;
}
.nav-right {
    display:flex;
    align-items:center;
    gap:8px; /* Space between elements if you add more */
}
.header h1{font-size:.95rem;
    font-weight:700;
    color: var(--safari-gold);
    white-space:nowrap; /* Prevent wrapping */}

    .language-selector{
    display:flex;
    align-items:center;
}
.language-selector select{
    background:#fff;
    color:var(--deep-purple);
    border:1px solid var(--deep-purple);
    border-radius:4px;
    font-size:.75rem;
    padding:4px 8px;
    min-width:60px;
    cursor:pointer;
    outline:none;
}
.language-selector select:focus{
    border-color:var(--orange);
    box-shadow:0 0 0 2px rgba(255,154,60,0.2);
}

@media(max-width:500px){
    /* ... other mobile styles ... */
    
    /* Adjust language selector for mobile */
    .language-selector select{
        font-size:.7rem;
        padding:3px 6px;
        min-width:55px;
    }
    
    .header h1{
        font-size:.85rem;
    }
}

/* DASHBOARD - FIXED 5 STATS SIDE BY SIDE */
.stats-dashboard{
    background: var(--charcoal-dark);
    padding:4px 6px;
    gap:4px;
    height:48px;
    display:grid;
    grid-template-columns:repeat(5, 1fr) !important; /* FORCE 5 COLUMNS */
    grid-template-rows:1fr !important; /* SINGLE ROW */
}
.stat-card{
     background: linear-gradient(90deg, rgba(53, 94, 78, 0.1) 0%, rgba(105, 150, 139, 0.05) 100%);
    border-radius:6px;
    border:1px solid #eee;
    text-align:center;
    display:flex;
    flex-direction:column;
    justify-content:center;
    padding:2px;
    min-width:0; /* Allow shrinking */
}
.stat-label{
    font-size:.75rem;
   color: var(--desert-sand);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    padding:0 1px;
}
.stat-value{
    font-size:.75rem;
    font-weight:700;
    color: var(--ivory-white);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    padding:0 1px;
}

/* SIDE-BY-SIDE ALWAYS */
.game-layout{
    background: var(--ivory-white);
    flex:1;
    display:grid;
    grid-template-columns:55% 45% !important;
    overflow:hidden;
    padding:0;
    margin:0;
}

/* LEFT BINGO BOARD PANEL */
.main-bingo-board{
    background: linear-gradient(135deg, var(--savannah-green) 0%, var(--ethiopian-blue) 100%);
    padding:5px !important;
    border-right:2px solid #b493e8;
    display:flex;
    flex-direction:column;
}

/* Slight increase for readability after shrinking */
.board-letter { font-size: 0.75rem !important; }
.bingo-cell { font-size: 1.2rem !important; }
.stat-value { font-size: .85rem !important; }
.stat-label { font-size: .85rem !important; }
.call-number { font-size: 1.2rem !important; }
.call-letter { font-size: 0.9rem !important; }
.called-number-item { font-size: .65rem !important; }
.player-boards-title { font-size: .75rem !important; }
.board-miniature { font-size: 0.8rem !important; }
.bingo-table td { font-size: 1rem!important; }
.bingo-table th { font-size: 1rem !important; }

/* B | I | N | G | O HEADER - COMPACT VERSION */
.board-header {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 2px; /* Reduced from 3px */
    margin-bottom: 5px;
}

.board-letter {
    border-radius: 4px; /* Slightly smaller */
    font-size: 0.85rem !important; /* Optimized size */
    text-align: center;
    font-weight: bold;
    /* REMOVED: min-height, flex, align-items, justify-content */
    padding: 3px 0; /* Minimal vertical padding */
    line-height: 1.2; /* Tight line spacing */
    transition: transform 0.2s;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
}

/* Individual letter colors */
.board-letter.b { /* B - Blue */
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
    color: white;
}

.board-letter.i { /* I - Orange/Red */
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    color: white;
}

.board-letter.n { /* N - Green */
    background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
    color: white;
}

.board-letter.g { /* G - Gold/Yellow */
    background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%);
   color: #2c3e50;
}

.board-letter.o { /* O - Purple */
    background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
    color: white;
}

/* Colored BINGO headers for winner boards */
.b-header {
    background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
    color: white !important;
    border-bottom: 2px solid #2980b9 !important;
}

.i-header {
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
    color: white !important;
    border-bottom: 2px solid #c0392b !important;
}

.n-header {
    background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%) !important;
    color: white !important;
    border-bottom: 2px solid #27ae60 !important;
}

.g-header {
    background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%) !important;
    color: #2c3e50 !important;
    border-bottom: 2px solid #f39c12 !important;
}

.o-header {
    background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%) !important;
    color: white !important;
    border-bottom: 2px solid #8e44ad !important;
}
/* Desktop adjustments - More compact */
@media (min-width: 768px) {
    .board-header {
        gap: 2px;
        margin-bottom: 6px;
    }
    
    .board-letter {
        font-size: 0.9rem !important; /* Slightly larger but still compact */
        padding: 4px 0; /* Minimal increase */
        line-height: 1.3;
    }
}

/* Mobile - Extra compact */
@media (max-width: 480px) {
    .board-header {
        gap: 1px;
        margin-bottom: 4px;
    }
    
    .board-letter {
        font-size: 0.75rem !important;
        padding: 2px 0;
        line-height: 1.1;
    }
}


/* GRID OF 75 NUMBERS */
.main-bingo-grid{
    display:grid;
    grid-template-columns:repeat(5,1fr);
    grid-template-rows:repeat(15,1fr);
    gap:3px;
}
.bingo-cell{
    background:white;
    border-radius:6px;
    border:1px solid #d5c4f0;
    color:var(--text-dark);
     font-size: 1.2rem !important;
    font-weight: 600 !important;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0 !important;
}

/* CURRENT + PREVIOUS CALL */
.bingo-cell.current-called{background:var(--green);color:white;font-size:.85rem !important;}
.bingo-cell.previously-called{background:var(--yellow);color:#222;font-size:.78rem !important;}



/* RIGHT STATUS PANEL */
.game-status-panel{
     background: linear-gradient(45deg, var(--savannah-green) 0%, var(--ethiopian-blue) 100%);
    padding:10px;
    display:flex;
    flex-direction:column;
    gap:10px;
}

/* GAME STATUS BADGE */
.status-badge{
    background: linear-gradient(45deg, #6B7280 0%, #9CA3AF 100%);
    color: white;
    padding:6px;
    border-radius:6px;
    text-align:center;
    font-size:0.75rem;
    font-weight:700;
}


.status-badge.game-waiting {
    background: linear-gradient(45deg, #6B7280 0%, #9CA3AF 100%);
}

.status-badge.game-selecting {
    background: linear-gradient(45deg, var(--sunset-orange) 0%, #FF8C42 100%);
}

.status-badge.game-shuffling {
    background: linear-gradient(45deg, var(--royal-purple) 0%, #9B59B6 100%);
}

.status-badge.game-started {
    background: linear-gradient(45deg, var(--savannah-green) 0%, #34D399 100%);
}

.status-badge.game-checking {
    background: linear-gradient(45deg, var(--called-yellow) 0%, #F59E0B 100%);
}

.status-badge.game-finished {
    background: linear-gradient(45deg, #DC2626 0%, #EF4444 100%);
}

/* CURRENT CALL BOX */
.current-call{
    background: rgba(255, 255, 255, 0.1);
    border-radius:8px;
    padding:0px;
    text-align:center;
}
.call-label{font-size:.75rem;font-weight:700;color: var(--desert-sand);}
.call-display{padding:3px;display:flex;justify-content:center;gap:6px;margin-top:6px;}
.call-letter{
    width:28px;height:28px;border-radius:50%;    
    background: var(--safari-gold);
    color: var(--charcoal-dark);    
    font-size:1.2rem;font-weight:700;
    display:flex;align-items:center;justify-content:center;
}
.call-number{
    font-size:1.2rem !important;
    font-weight:800;    
    color: var(--safari-gold);
}
/* CALLED NUMBERS ROW */
/* RECENTLY CALLED SECTION */
.called-numbers-section {
   width: 100%;
    background: var(--light-purple);
    padding: 6px;
    border-radius: 6px;
    text-align: center;
    font-size: .75rem;
    font-weight: 700;
    margin: 5px 0;
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.called-numbers-label {
     color: var(--desert-sand);
    font-size: 0.8rem;
    font-weight: 600;
    margin-bottom: 6px;
    letter-spacing: 0.5px;
}

.called-numbers-list {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 3px;
    padding: 3px 0;
    min-height: 32px;    
}

/* Remove all spacing between these two sections */
.called-numbers-section,
.current-board-container {
    margin: 0 !important;
    padding: 0 !important;
}

/* Ensure they touch each other */
.called-numbers-list {
    margin-bottom: 0;
    padding-bottom: 0;
}

.player-bingo-board {
    margin-top: 0;
    padding-top: 0;
}
/* For mobile devices */
@media (max-width: 480px) {
    .called-numbers-section {
        padding: 6px 4px;
        min-height: 60px;
        margin: 8px 0;
    }
    
    .called-numbers-label {
        font-size: 0.8rem;
        margin-bottom: 4px;
        padding-bottom: 3px;
    }
    
    .called-numbers-list {
        min-height: 35px;
        padding: 3px 0;
    }
}

/* For very small screens */
@media (max-width: 360px) {
    .called-numbers-section {
        padding: 5px 3px;
        min-height: 55px;
        margin: 6px 0;
    }
    
    .called-numbers-label {
        font-size: 0.75rem;
        margin-bottom: 3px;
        padding-bottom: 2px;
    }
    
    .called-numbers-list {
        min-height: 32px;
        padding: 2px 0;
    }
}
/* PLAYER BOARD AREA (collapsed style like GeezBingo) */
.player-boards-section{
    background: linear-gradient(135deg, var(--charcoal-dark) 0%, var(--savannah-green) 100%);
    padding:10px;
    border-radius:8px;
}
.player-boards-title{color: var(--desert-sand);font-size: 0.8rem;font-weight: 600;padding-left: 5px;}

.boards-carousel {
     background: linear-gradient(135deg, rgba(248, 250, 252, 0.95) 0%, rgba(241, 245, 249, 0.9) 100%);
    display: flex !important;
    flex-direction: row !important;
    flex-wrap: nowrap !important;
    overflow-x: auto !important;
    gap: 5px;
    padding: 5px;
    white-space: nowrap;
    min-height: 35px;
    align-items: center;
}

.board-miniature{
   flex-shrink: 0 !important;
    display: inline-flex !important;
    align-items: center;
    justify-content: center;
    background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
    border: 1px solid var(--safari-gold);
    border-radius: 6px;
    font-size: 0.8rem;
    font-weight: 600;
    color: #475569;
    cursor: pointer;
    min-width: 45px;
    text-align: center;
    transition: all 0.2s ease;
}
.board-miniature.active{
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-color: #c9cce6;
    color: white;
    transform: scale(1.05);
}
/* MINI TABLE CONTAINER */
.bingo-table-container {
    display: block;
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    padding-left: 0 !important; /* Force no left padding */
    padding-right: 10px !important; /* Force right gap */
    margin: 0;
    box-sizing: border-box;
    position: relative;
}

/* For Webkit browsers (Chrome, Safari) */
.bingo-table-container::-webkit-scrollbar {
    height: 4px;
}

.bingo-table-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 2px;
}

.bingo-table-container::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 2px;
}

.bingo-table-container::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* THE TABLE ITSELF */
.bingo-table {
    width: 100%;
    min-width: 100%; /* Ensure it takes full width */
    border-collapse: collapse;
    background: var(--deep-purple);
    border-radius: 5px;
    overflow: hidden;
    margin: 0;
    table-layout: auto; /* Let browser handle sizing */
}

/* Force table to not exceed container width */
.bingo-table,
.bingo-table * {
    box-sizing: border-box;
}

/* Headers and cells */
.bingo-table th {
    padding: 6px 3px;
    text-align: center;
    font-weight: 700;
    font-size: 0.85rem;
    border-bottom: 2px solid rgba(0, 0, 0, 0.1);
    line-height: 1.2;
}

.bingo-table td {
    background: white;
    color: var(--text-dark);
    text-align: center;
    font-size: 0.9rem;
    font-weight: 600;
    padding: 8px 3px;
    height: 35px;
    min-height: 35px;
    line-height: 1.2;
    vertical-align: middle;
    border: 1px solid #e0d6f0;
}

/* Color classes */
.bingo-table th.b { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; }
.bingo-table th.i { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; }
.bingo-table th.n { background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white; }
.bingo-table th.g { background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%); color: #2c3e50; }
.bingo-table th.o { background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; }

/* RESPONSIVE BREAKPOINTS */
@media (max-width: 768px) {
    .bingo-table-container {
        padding-right: 8px !important;
    }
    
    .bingo-table th {
        font-size: 0.8rem;
        padding: 5px 2px;
    }
    
    .bingo-table td {
        font-size: 0.85rem;
        padding: 7px 2px;
        height: 32px;
        min-height: 32px;
    }
}

@media (max-width: 480px) {
    .bingo-table-container {
        padding-right: 6px !important;
    }
    
    .bingo-table th {
        font-size: 0.75rem;
        padding: 4px 1px;
    }
    
    .bingo-table td {
        font-size: 0.8rem;
        padding: 6px 1px;
        height: 30px;
        min-height: 30px;
    }
}

@media (max-width: 360px) {
    .bingo-table-container {
        padding-right: 4px !important;
    }
    
    .bingo-table th {
        font-size: 0.7rem;
        padding: 3px 1px;
    }
    
    .bingo-table td {
        font-size: 0.75rem;
        padding: 5px 1px;
        height: 28px;
        min-height: 28px;
    }
}

/* SPECIAL CELLS */
.bingo-table td.free-space {
    background: var(--green);
    color: white;
    font-size: 1rem;
    font-weight: 800;
}

.bingo-table td.marked {
    background: var(--green);
    color: white;
    position: relative;
}

.bingo-table td.marked::after {
    content: "‚úì";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.1rem;
    font-weight: bold;
}

/* FIX FOR PARENT CONTAINERS */
.player-boards-section {
    display: block;
    width: 100%;
    max-width: 100%;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
}

.player-board {
    display: block;
    width: 100%;
    max-width: 100%;
    margin: 0;
    padding: 0 0 0 0; /* No horizontal padding */
    box-sizing: border-box;
    overflow: hidden;
}

/* Reset any conflicting styles */
.bingo-table-container * {
    max-width: none !important; /* Remove any max-width restrictions */
}

/* Ensure the right gap is visible */
.bingo-table-container:after {
    content: '';
    display: block;
    width: 0;
    height: 1px;
    clear: both;
}

.bingo-btn {
    /* KEEP YOUR EXACT SIZE PROPERTIES */
    padding: clamp(4px, 1vw, 6px) clamp(6px, 1.5vw, 10px);
    border-radius: clamp(2px, 0.5vw, 3px);
    font-weight: 700;
    font-size: clamp(0.5rem, 1.2vw, 0.7rem);
    text-transform: uppercase;
    letter-spacing: 0.3px;
    width: 100%;
    cursor: pointer;
    transition: all 0.3s ease;
    
    /* ENHANCED COLOR PROPERTIES */
    background: linear-gradient(45deg, 
        #ff6b35 0%,       /* --sunset-orange */
        #f7c46c 25%,      /* --safari-gold */
        #6b46c1 50%,      /* --royal-purple */
        #2e8b57 75%,      /* --savannah-green */
        #1e3a8a 100%      /* --ethiopian-blue */
    );
    background-size: 200% 200%;
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 
        0 2px 5px rgba(0, 0, 0, 0.2),
        inset 0 1px 2px rgba(255, 255, 255, 0.3);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}
@media (max-width: 768px) {
    .bingo-table th {      
        padding: 1px !important;  /* Minimal padding */
        font-size: 0.75rem !important;        
    }
    
    .bingo-table td {
        padding: 2px 1px !important;
        font-size: 0.7rem !important;
        padding: 2px 1px !important;
        font-size: 0.7rem !important;
        min-height: 25px;
        height: 25px;
    }
}
@media (max-width: 500px) {
    /* Even more compact on mobile */
    .boards-carousel {
        min-height: 28px !important;
        max-height: 30px !important;
        padding: 2px !important;
    }
    
    .board-miniature {
        font-size: 0.55rem !important;
        padding: 1px 4px !important;
        min-width: 30px;
        height: 20px;
        line-height: 16px;
    }
    
    /* Compact winner popup on mobile */
    .winners-list {
        padding: 15px !important;
        max-width: 95% !important;
        max-height: 80vh !important;
    }
}

/* Add to your existing CSS */
.wait-message {
    text-align: center;
    padding: 30px 20px;
    color: var(--deep-purple);
    font-size: 1.2rem;
    font-weight: bold;
    background: white;
    border-radius: 10px;
    margin: 15px 0;
    border: 2px solid var(--deep-purple);
    box-shadow: 0 4px 12px rgba(139, 61, 232, 0.2);
}

.wait-message div {
    margin-bottom: 10px;
}

.wait-message .timer {
    font-size: 1.5rem;
    color: var(--orange);
    font-weight: 800;
    margin: 10px 0;
}



/* ========================
   POPUP STYLES (JAVASCRIPT COMPATIBLE)
   ======================== */

/* POPUP OVERLAY - KEEP YOUR STYLE */
.popup-overlay{
    display:none;
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.7);
    backdrop-filter:blur(4px);
    z-index:1000;
    align-items:center;
    justify-content:center;
    padding:15px;
}

/* Popup Content - Match your original HTML structure */
.board-selection-section{
    background:white;
    border-radius:10px;
    overflow:hidden;
    border:2px solid var(--deep-purple);
    width:100%;
    max-width:380px;
    box-shadow:0 10px 25px rgba(0,0,0,0.2);
}

/* Selection Info */
.selection-info{
    background:linear-gradient(135deg,#2c3e50,#34495e);
    color:white;
    padding:8px 10px;
    margin:10px;
    border-radius:8px;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:6px;
}
.info-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:4px 6px;
    background:rgba(255,255,255,0.15);
    border-radius:4px;
    font-size:.65rem;
}
.info-item strong{
    color:var(--safari-gold);
    font-size:.75rem;
}

/* Boards Grid */
.boards-grid{
    display:grid;
    grid-template-columns:repeat(8,1fr);
    gap:4px;
    margin:0 10px 10px;
    max-height:250px;
    overflow-y:auto;
    padding:8px;
    background:#f8f9fa;
    border-radius:6px;
    border:1px solid #dee2e6;
}
.board-option{
    background:white;
    border:1px solid #ced4da;
    border-radius:5px;
    padding:6px 4px;
    text-align:center;
    cursor:pointer;
    min-height:35px;
    display:flex;
    align-items:center;
    justify-content:center;
}
.board-number{
    font-weight:700;
    font-size:.7rem;
    color:var(--text-dark);
}
.board-option.selected{
    background:var(--green);
    color:white;
    border-color:var(--green);
}
.board-option.taken{
    background:var(--red);
    color:white;
    cursor:not-allowed;
    opacity:0.7;
}

/* Selection Summary */
.selection-summary{
    background:linear-gradient(135deg,var(--deep-purple),var(--royal-purple));
    color:white;
    padding:10px;
    border-radius:8px;
    margin:0 10px 10px;
    display:grid;
    grid-template-columns:repeat(2,1fr);
    gap:8px;
}
.summary-item{
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:6px 8px;
    background:rgba(255,255,255,0.2);
    border-radius:5px;
    font-size:.7rem;
}
.summary-item strong{
    font-size:.8rem;
    color:var(--safari-gold);
}

/* Popup Actions */
.popup-actions{
    display:flex;
    justify-content:center;
    gap:10px;
    padding:12px;
    background:#f8f9fa;
    border-top:1px solid #dee2e6;
}
.btn-primary, .btn-secondary{
    padding:8px 16px;
    border:none;
    border-radius:6px;
    font-size:.75rem;
    font-weight:600;
    cursor:pointer;
    min-width:100px;
}
.btn-primary{
    background:linear-gradient(135deg,var(--green),#27ae60);
    color:white;
}
.btn-secondary{
    background:linear-gradient(135deg,#6c757d,#5a6268);
    color:white;
}

/* Winners Popup */
.winners-list{
    background:white;
    color:var(--text-dark);
    padding:15px;
    border-radius:10px;
    border:2px solid var(--deep-purple);
    max-height:70vh;
    overflow-y:auto;
    width:90%;
    max-width:400px;
}
.winner-board-grid{
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:3px;
    background:rgba(255,255,255,0.1);
    padding:8px;
    border-radius:8px;
    margin:8px 0;
}
.winner-board-cell{
    padding:5px 3px;
    text-align:center;
    border-radius:5px;
    font-size:.7rem;
    font-weight:bold;
    background:white;
    border:1px solid #e0d6f0;
    color:var(--text-dark);
}

/* ========================
   RESPONSIVE ADJUSTMENTS
   ======================== */

/* For small screens - keep all 5 stats in one row but smaller */
@media(max-width:500px){
    .game-layout{
        grid-template-columns:52% 48% !important;
    }
    .bingo-cell{font-size:.68rem !important;}
    .board-letter{font-size:.7rem !important;}
    
    /* Stats dashboard - smaller but still 5 in one row */
    .stats-dashboard{
        height:44px;
        padding:3px 4px;
        gap:3px;
    }
    .stat-label{
        font-size:.5rem;
        padding:0;
    }
    .stat-value{
        font-size:.65rem;
        padding:0;
    }
    
    /* Adjust popup for mobile */
    .popup-overlay{
        padding:10px;
    }
    .board-selection-section{
        max-width:320px;
    }
    .boards-grid{
        grid-template-columns:repeat(6,1fr);
        max-height:200px;
    }
    .selection-info, .selection-summary{
        grid-template-columns:1fr;
    }
    .popup-actions{
        flex-direction:column;
        gap:6px;
    }
    .btn-primary, .btn-secondary{
        width:100%;
        min-width:auto;
    }
}

/* For very small screens - keep 5 stats but ultra-compact */
@media(max-width:360px){
    .stats-dashboard{
        height:40px;
        padding:2px 3px;
        gap:2px;
    }
    .stat-label{
        font-size:.45rem;
    }
    .stat-value{
        font-size:.6rem;
    }
}

/* Support Button */
.support-btn{
    position:fixed;
    bottom:15px;
    right:15px;
    width:25px;
    height:25px;
    background:#0088cc;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    box-shadow:0 2px 8px rgba(0,0,0,0.3);
    z-index:999;
    font-size:12px;
}
/* Glow animation for most recent call */
@keyframes recentGlow {
    0% {
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.6), 0 2px 8px rgba(0,0,0,0.3);
    }
    100% {
        box-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 0 4px 12px rgba(0,0,0,0.4);
    }
}
/* Scrollbar */
::-webkit-scrollbar{
    width:4px;
    height:4px;
}
::-webkit-scrollbar-track{
    background:rgba(255,255,255,0.1);
}
::-webkit-scrollbar-thumb{
    background:var(--deep-purple);
    border-radius:2px;
}

/* Force stats to stay in one row no matter what */
.stat-card {
    flex-shrink: 0;
    min-width: 0;
    overflow: hidden;
}
        
    </style>
</head>
<body>   
    <div class="game-container">
      <nav class="top-nav">            
        <!-- Header -->
        <div class="header">
            <h1> üéØ ShebaBingo </h1>        
        </div>
            <div class="nav-right">                
                <div class="language-selector"  id ="languageSelector">
                    <select id="languageSelect">
                        <option value="en">EN</option>
                        <option value="am">AM</option>
                    </select>
                    
                </div>
            </div>
        </nav>     
        
        <!-- Main Stats Dashboard -->
        <div class="stats-dashboard">
            <div class="stat-card">
                <div class="stat-label">üí∞ Balance</div>
                <div class="stat-value" id="balanceValue">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üèÜ Prize</div>
                <div class="stat-value" id="prizeValue">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üë• Players</div>
                <div class="stat-value" id="playersValue">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">‚ö° Bet</div>
                <div class="stat-value">10</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">üéØ Called</div>
                <div class="stat-value" id="calledCount">0</div>
            </div>
        </div>

        <!-- Main Game Layout -->
        <div class="game-layout">
            <!-- Main Bingo Board Section -->
            <div class="main-bingo-board">
               <div class="board-header">
    <div class="board-letter b">B</div>
    <div class="board-letter i">I</div>
    <div class="board-letter n">N</div>
    <div class="board-letter g">G</div>
    <div class="board-letter o">O</div>
</div>
                
                <div class="main-bingo-grid" id="bingoGrid">
                    <!-- Main bingo board numbers will be generated here -->
                </div>
            </div>
            
            <!-- Game Status Panel -->
            <div class="game-status-panel">
                <div class="status-badge" id="gameStatus">Waiting for Next Game</div>
                
                <div class="current-call">
                    <div class="call-label">Current Call</div>
                    <div class="call-display">
                        <div class="call-letter" id="currentLetter">-</div>
                        <div class="call-number" id="currentNumber">-</div>
                    </div>
                </div>
                
                <div class="called-numbers-section">
                    <div class="called-numbers-label">Recently Called</div>
                    <div class="called-numbers-list" id="calledNumbersList">
                        <!-- Called numbers will appear here -->
                    </div>
                </div>
                
 <!-- Player Boards Section -->
            <div class="player-boards-section" id="gamePlaySection" style="display: none;">
                <div class="player-boards-container">
                    <h3 class="player-boards-title">Your Bingo Boards</h3>          
                        <div class="boards-carousel" id="boardsCarousel">
                            <!-- Player's boards will be displayed here -->
                        </div>
                    </div>                   
                    
                    <div class="current-board-container">
                        <div class="player-bingo-board" id="currentBoard">
                            <!-- Current board will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
            </div>           
        </div>
    </div>

    <!-- Registration Popup (Board Selection) -->
    <div id="registrationPopup" class="popup-overlay" style="display: none;">
        <div class="popup-content large-popup">
            
            <div class="board-selection-section">
                <div class="selection-info">
                    <div class="info-item">
                        <span>Price per board:</span>
                        <strong>10</strong>
                    </div>
                    <div class="info-item">
                        <span>Max boards per player:</span>
                        <strong>3</strong>
                    </div>
                    <div class="info-item">
                        <span>Time remaining:</span>
                        <strong id="selectionTimer">25 seconds</strong>
                    </div>
                </div>
                
                <div class="boards-grid" id="boardsGrid">
                    <!-- Boards will be generated by JavaScript -->
                </div>
                
                <div class="selection-summary">
                    <div class="summary-item">
                        <span>Boards Selected:</span>
                        <strong id="selectedCount">0</strong>
                    </div>
                    <div class="summary-item">
                        <span>Total Cost:</span>
                        <strong id="totalCost">0</strong>
                    </div>
                </div>

                <div class="popup-actions">
                    <button class="btn-secondary" onclick="closeRegistrationPopup()">Cancel</button>
                    <button id="confirmSelection" class="btn-primary" disabled>Confirm Selection & Join Game</button>
                </div>
            </div>
        </div>
    </div>


    <!-- All JavaScript Code -->
    <script>
        // Game Configuration
        // Game Configuration
        const CONFIG = {
            BET_AMOUNT: 10,
            TOTAL_BOARDS: 400,
            MAX_BOARDS_PER_PLAYER: 3,
            SELECTION_TIME: 25,
            SHUFFLE_TIME: 3,
            CHECKING_TIME: 3,
            BINGO_NUMBERS: {
                'B': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
                'I': [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
                'N': [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45],
                'G': [46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60],
                'O': [61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75]
            },
            
            GAME_MODES: {
                classic: {
                    name: 'Classic Bingo',
                    enabled: true,
                    description: 'Complete any row, column, or diagonal',
                    callInterval: 3000
                }
            },
            
            BOT_DIFFICULTY: {
                easy: {
                    name: 'Easy',
                    description: 'Marks numbers slowly',
                    reactionTime: { min: 3000, max: 8000 },
                    markChance: 0.7
                },
                medium: {
                    name: 'Medium', 
                    description: 'Strategic marking',
                    reactionTime: { min: 2000, max: 5000 },
                    markChance: 0.85
                },
                hard: {
                    name: 'Hard',
                    description: 'Multiple board strategy', 
                    reactionTime: { min: 1000, max: 3000 },
                    markChance: 0.95
                }
            },
            
            LAZYLOAD: {
                enabled: false,
                enableServiceWorker: false
            }
        };

        // Internationalization Support - Amharic & English Only
        const TRANSLATIONS = {
            en: {
                // Game Status
                waiting: "Waiting for Next Game",
                selecting: "Selecting Boards",
                shuffling: "Shuffling Numbers...",
                started: "Game Started",
                checking: "Checking for BINGO...",
                finished: "Game Finished",
                
                // UI Elements
                balance: "Balance",
                prize: "Prize",
                players: "Players",
                bet: "Bet",
                called: "Called",
                currentCall: "Current Call",
                recentlyCalled: "Recently Called",
                howToWin: "How to Win",
                winCondition: "Row ‚Ä¢ Column ‚Ä¢ Diagonal",
                yourBoards: "Your Bingo Boards",
                claimBingo: "üéØ CLAIM BINGO",
                
                // Registration
                pricePerBoard: "Price per board:",
                maxBoards: "Max boards per player:",
                timeRemaining: "Time remaining:",
                boardsSelected: "Boards Selected:",
                totalCost: "Total Cost:",
                cancel: "Cancel",
                confirmJoin: "Confirm Selection & Join Game",
                
                // Messages
                boardTaken: "This board is already taken by another player!",
                maxBoardsReached: "Maximum 3 boards allowed per player",
                selectOneBoard: "Please select at least one board",
                insufficientBalance: "Insufficient balance",
                cannotClaimBingo: "You cannot claim BINGO at this time.",
                fraudDetected: "FRAUD DETECTED! You marked numbers that were not called. Board(s) eliminated!",
                noBingo: "All boards eliminated - No BINGO found!",
                allFraud: "All boards eliminated due to FRAUD! You marked uncalled numbers.",
                
                // Winner Notification
                you: "(YOU) üíπ",
                nextGame: "Next game starting automatically...",
                seconds: "Sec",

            
                // New Features
                live: "LIVE",
                spectator: "Spectator Mode",
                watching: "Watching Game",
                joinNext: "Join Next Game",

// NEW: Game title and other static text
        gameTitle: "üéØ ShebaBingo",
        supportTitle: "üí¨ Support",
        howToPlay: "How to Play",
        payments: "Payments",
        prizes: "Prizes",
        gameRules: "Game Rules",
        
        // NEW: Support modal content
        supportTelegram: "Contact us on Telegram",
        supportHelp: "Quick Help & FAQ",
        supportCall: "Call Support",
        supportContact: "Need more help? Contact us via Telegram or phone!",
        
        // NEW: Game instructions
        selectBoardsInstruction: "Select 1-3 boards during registration",
        markNumbersInstruction: "Mark numbers as they are called",
        winConditionInstruction: "Complete a row, column, or diagonal to win",
        claimBingoInstruction: 'Click "CLAIM BINGO" when you have a winning pattern',
        boardCostInstruction: "Each board costs 10 ETB to play",
        
        // NEW: Payment instructions
        minDeposit: "Minimum deposit: 10 ETB",
        minWithdrawal: "Minimum withdrawal: 50 ETB ",
        supportedPayment: "Supported: Telebirr, CBE, BOA",
        withdrawalTime: "Withdrawals processed within 5 minutes",
        
        // NEW: Prize instructions
        autoPrize: "Prizes automatically added to balance",
        multipleWinners: "Multiple winners split the prize",
        
        // NEW: Call support
        callSupportTitle: "üìû Call Support",
        immediateAssistance: "For immediate assistance, call our support team:",
        supportNumber: "+251945343143",
        supportAvailability: "Available 24/7 for game support and account issues",
        
        // NEW: Fraud messages
        fraudClaimed: "üö® You claimed BINGO without a valid pattern. board eliminated!",
        // In the Amharic section:
           fraudClaimed: "üö® ·àç·ä≠ ·ã´·àç·àÜ·äê ·äï·ãµ·çç ·ã®·àå·àà·ãç ·â¢·äï·åé ·ä†·àù·å•·â∞·ãã·àç·ç¢ ·â¶·à≠·ã± ·â∞·à∞·à≠·ãü·àç!",
        
        // NEW: No winner message
        noWinnerRound: "No Winners This Round!",
        prizeCarryOver: "Prize carried over to next game",
        
        // NEW: Table headers
        bingoB: "B",
        bingoI: "I",
        bingoN: "N",
        bingoG: "G",
        bingoO: "O",
        
        // NEW: Game phases
        gameOver: "Game Over",
        selectingBoards: "Selecting Boards",
        shufflingNumbers: "Shuffling Numbers",
        gameInProgress: "Game In Progress",
        checkingBingo: "Checking Bingo",
        
        // NEW: Button texts
        playBingo: "üéÆ PLAY BINGO",
        close: "Close",
        ok: "OK"

            },
            am: {
                // Game Status
        waiting: "·ã®·àö·âÄ·å•·àà·ãç ·å®·ãã·â≥ ·â†·àò·å†·â†·âÖ ·àã·ã≠",
        selecting: "·â¶·à≠·ã∂·âΩ ·â†·àò·àù·à®·å• ·àã·ã≠",
        shuffling: "·âÅ·å•·àÆ·âΩ ·â†·àõ·ã∞·â£·àà·âÖ ·àã·ã≠...",
        started: "·å®·ãã·â≥·ãç ·åÄ·àù·àØ·àç",
        checking: "·â¢·äï·åé ·â†·àò·çà·â∞·àΩ ·àã·ã≠...",
        finished: "·å®·ãã·â≥·ãç ·â∞·å†·äì·âã·àç",
        
        // UI Elements
        balance: "·âÄ·à™ ·àÇ·à≥·â•",
        prize: "·àΩ·àç·àõ·âµ",
        players: "·â∞·å´·ãã·âæ·âΩ",
        bet: "·ãç·à≠·à≠·ãµ",
        called: "·ã®·â∞·å†·à´",
        currentCall: "·ã®·ä†·àÅ·äë ·å•·à™",
        recentlyCalled: "·â†·âÖ·à≠·â• ·åä·ãú ·ã®·â∞·å†·à©",
        howToWin: "·ä•·äï·ã¥·âµ ·ä•·äï·ã∞·àö·ã´·à∏·äï·çâ",
        winCondition: "·à®·ãµ·çç ‚Ä¢ ·ä†·àù·ãµ ‚Ä¢ ·à∞·ã´·çç",
        yourBoards: "·ã®·ä•·à≠·àµ·ãé ·â¢·äï·åé ·â¶·à≠·ã∂·âΩ",
        claimBingo: "üéØ ·â¢·äï·åé ·ä†·àà·äù",
        
        // Registration
        pricePerBoard: "·ã®·ä†·äï·ãµ ·â¶·à≠·ãµ ·ãã·åã:",
        maxBoards: "·ä®·çç·â∞·äõ ·â¶·à≠·ã∂·âΩ ·â†·ä†·äï·ãµ ·â∞·å´·ãã·âΩ:",
        timeRemaining: "·ã®·âÄ·à®·ãç ·åä·ãú:",
        boardsSelected: "·ã®·â∞·àò·à®·å° ·â¶·à≠·ã∂·âΩ:",
        totalCost: "·å†·âÖ·àã·àã ·ãà·å™:",
        cancel: "·à∞·à≠·ãù",
        confirmJoin: "·àù·à≠·å´ ·ä†·à®·åã·åç·å• ·ä•·äì ·ãà·ã∞ ·å®·ãã·â≥ ·ã≠·âÄ·àã·âÄ·àâ",
        
        // Messages
        boardTaken: "·ã≠·àÖ ·â¶·à≠·ãµ ·â†·àå·àã ·â∞·å´·ãã·âΩ ·â∞·ã´·ãù·â∑·àç!",
        maxBoardsReached: "·ä®·çç·â∞·äõ·ãç 3 ·â¶·à≠·ã∂·âΩ ·â•·âª ·ã≠·çà·âÄ·ã≥·àâ",
        selectOneBoard: "·ä•·â£·ä≠·ãé ·â¢·ã´·äï·àµ ·ä†·äï·ãµ ·â¶·à≠·ãµ ·ã≠·àù·à®·å°",
        insufficientBalance: "·â†·âÇ ·âÄ·à™ ·àÇ·à≥·â• ·ã®·àà·àù",
        cannotClaimBingo: "·â†·ãö·àÖ ·åä·ãú ·â¢·äï·åé ·àõ·àù·å£·âµ ·ä†·ã≠·âΩ·àâ·àù·ç¢",
        fraudDetected: "·àõ·å≠·â†·à≠·â†·à≠ ·â∞·åà·äù·â∑·àç! ·ã´·àç·â∞·å†·à© ·âÅ·å•·àÆ·âΩ·äï ·àù·àç·ä≠·âµ ·ä†·ãµ·à≠·åà·ãã·àç·ç¢ ·â¶·à≠·ãµ(·ãé·âΩ) ·â∞·à∞·à≠·ãò·ãã·àç!",
        noBingo: "·àÅ·àâ·àù ·â¶·à≠·ã∂·âΩ ·â∞·à∞·à≠·ãò·ãã·àç - ·â¢·äï·åé ·ä†·àç·â∞·åà·äò·àù!",
        allFraud: "·àÅ·àâ·àù ·â¶·à≠·ã∂·âΩ ·â†·àõ·å≠·â†·à≠·â†·à≠ ·â∞·à∞·à≠·ãò·ãã·àç! ·ã´·àç·â∞·å†·à© ·âÅ·å•·àÆ·âΩ·äï ·àù·àç·ä≠·âµ ·ä†·ãµ·à≠·åà·ãã·àç·ç¢",
        
        // Winner Notification
        you: "(·ä†·äï·â∞) üíπ",
        nextGame: "·ã®·àö·âÄ·å•·àà·ãç ·å®·ãã·â≥ ·â†·à´·àµ ·à∞·à≠ ·ä•·ã®·åÄ·àò·à®...",
        seconds: "·à∞·ä®·äï·ãµ",
        
        // New Features
        live: "·âÄ·å•·â≥",
        spectator: "·ã®·â∞·àò·àç·ä´·âΩ ·àÅ·äê·â≥",
        watching: "·å®·ãã·â≥·äï ·â†·àò·àò·àç·ä®·âµ ·àã·ã≠",
        joinNext: "·ãà·ã∞ ·âÄ·å£·ã© ·å®·ãã·â≥ ·ã≠·âÄ·àã·âÄ·àâ",
        
        // NEW: Game title and other static text
        gameTitle: "üéØ ·à∏·â£ ·â¢·äï·åé",
        supportTitle: "üí¨ ·ãµ·åã·çç",
        howToPlay: "·ä•·äï·ã¥·âµ ·ä•·äï·ã∞·àö·å´·ãà·â±",
        payments: "·ä≠·çç·ã´·ãé·âΩ",
        prizes: "·àΩ·àç·àõ·â∂·âΩ",
        gameRules: "·ã®·å®·ãã·â≥ ·ã∞·äï·â¶·âΩ",
        
        // NEW: Support modal content
        supportTelegram: "·â†·â¥·àå·åç·à´·àù ·ã´·åç·äô·äï",
        supportHelp: "·çà·å£·äï ·ä•·åà·ãõ ·ä•·äì ·å•·ã´·âÑ·ãé·âΩ",
        supportCall: "·ãµ·åã·çç ·ã≠·ã∞·ãç·àâ",
        supportContact: "·â∞·å®·àõ·à™ ·ä•·åà·ãõ ·ã®·àö·çà·àç·åâ? ·â†·â¥·àå·åç·à´·àù ·ãà·ã≠·àù ·àµ·àç·ä≠ ·ã´·åç·äô·äï!",
        
        // NEW: Game instructions
        selectBoardsInstruction: "·â†·àù·ãù·åà·â£ ·åä·ãú 1-3 ·â¶·à≠·ã∂·âΩ ·ã≠·àù·à®·å°",
        markNumbersInstruction: "·âÅ·å•·àÆ·âΩ ·ä•·ã®·â∞·å†·à© ·àù·àç·ä≠·âµ ·ã´·ãµ·à≠·åâ",
        winConditionInstruction: "·à®·ãµ·çç·ç£ ·ä†·àù·ãµ ·ãà·ã≠·àù ·à∞·ã´·çç ·ã≠·å†·äì·âÄ·âÅ",
        claimBingoInstruction: '·ã®·àõ·à∏·äê·çç ·äï·ãµ·çç ·à≤·äñ·à≠·ãé·âµ "·â¢·äï·åé ·ä†·àà·äù" ·ã≠·å´·äë',
        boardCostInstruction: "·ä•·ã´·äï·ã≥·äï·ã± ·â¶·à≠·ãµ $10 ·ã´·àµ·ä®·çç·àã·àç",
        
        // NEW: Payment instructions
        minDeposit: "·ä†·äê·àµ·â∞·äõ ·â∞·âÄ·àõ·å≠: 10 ETB",
        minWithdrawal: "·ä†·äê·àµ·â∞·äõ ·àò·àç·à∂ ·àõ·ãç·å£·âµ: 50 ETB",
        supportedPayment: "·ã®·àö·ã∞·åà·çâ: ·â¥·àå·â¢·à≠·ç£ ·ä¢·âµ·ãÆ·åµ·ã´ ·äï·åç·ãµ ·â£·äï·ä≠·ç£ ·â£·äï·ä≠ ·àõ·àµ·â∞·àã·àà·çç",
        withdrawalTime: "·àò·àç·à∂ ·àõ·ãç·å£·â∂·âΩ ·â†24 ·à∞·ãì·â≥·âµ ·ãç·àµ·å• ·ã≠·ä®·äì·ãà·äì·àâ",
        
        // NEW: Prize instructions
        autoPrize: "·àΩ·àç·àõ·â∂·âΩ ·â†·à´·àµ ·à∞·à≠ ·ãà·ã∞ ·âÄ·à™ ·àÇ·à≥·â• ·ã≠·å®·àò·à´·àâ",
        multipleWinners: "·â•·ãô ·ä†·à∏·äì·çä·ãé·âΩ ·àΩ·àç·àõ·â±·äï ·ã≠·ä´·çà·àã·àâ",
        
        // NEW: Call support
        callSupportTitle: "üìû ·ãµ·åã·çç ·ã≠·ã∞·ãç·àâ",
        immediateAssistance: "·àà·çà·å£·äï ·ä•·åà·ãõ·ç£ ·ã®·ãµ·åã·çç ·â°·ãµ·äì·âΩ·äï·äï ·ã≠·ã∞·ãç·àâ:",
        supportNumber: "+251945343143",
        supportAvailability: "·àà·å®·ãã·â≥ ·ãµ·åã·çç ·ä•·äì ·àÇ·à≥·â• ·âΩ·åç·àÆ·âΩ 24/7 ·ã≠·åà·äõ·àç",
        
        // NEW: No winner message
        noWinnerRound: "·â†·ãö·àÖ ·ãô·à≠ ·ä†·à∏·äì·çä ·ã®·àà·àù!",
        prizeCarryOver: "·àΩ·àç·àõ·â± ·àà·âÄ·å£·ã© ·å®·ãã·â≥ ·ã≠·ãõ·ãà·à´·àç",
        
        // NEW: Table headers
        bingoB: "B",
        bingoI: "I",
        bingoN: "N",
        bingoG: "G",
        bingoO: "O",
        
        // NEW: Game phases
        gameOver: "·å®·ãã·â≥·ãç ·ä†·àç·âã·àç",
        selectingBoards: "·â¶·à≠·ã∂·âΩ ·â†·àò·àù·à®·å• ·àã·ã≠",
        shufflingNumbers: "·âÅ·å•·àÆ·âΩ ·â†·àõ·ã∞·â£·àà·âÖ ·àã·ã≠",
        gameInProgress: "·å®·ãã·â≥·ãç ·ä•·ã®·â∞·ä´·àÑ·ã∞ ·äê·ãç",
        checkingBingo: "·â¢·äï·åé ·â†·àò·çà·â∞·àΩ ·àã·ã≠",
        
        // NEW: Button texts
        playBingo: "üéÆ ·â¢·äï·åé ·â∞·å´·ãç·âµ",
        close: "·àò·ãù·åã·âµ",
        ok: "·ä•·à∫"
    }
        };

        // Global Game State
        let gameState = {
            // Player state
            currentPlayer: {
                id: 1,
                name: 'You',
                telegramName: '@player1',
                balance: 0,
                boards: [],
                isActive: false,
                totalPaid: 0
            },
            
            // Multiplayer state
            allPlayers: [],
            activePlayers: [],
            winners: [],
            
            // Game state
            selectedBoards: new Set(),
            availableBoards: Array.from({length: CONFIG.TOTAL_BOARDS}, (_, i) => i + 1),
            gamePhase: 'waiting',
            calledNumbers: [],
            currentCall: null,
            selectionTimer: CONFIG.SELECTION_TIME,
            timerInterval: null,
            callInterval: null,
            
            // Game statistics
            totalPrizePool: 0,
            commissionRate: 0.20,
            ownerCommission: 0,
            totalCommissionEarned: 0,
            
            // Internationalization
            currentLanguage: 'en',
            
            // Track current board view
            currentBoardIndex: 0
        };

        // DOM Elements
        const elements = {
            // Main screen elements
            balanceValue: document.getElementById('balanceValue'),
            prizeValue: document.getElementById('prizeValue'),
            playersValue: document.getElementById('playersValue'),
            calledCount: document.getElementById('calledCount'),
            gameStatus: document.getElementById('gameStatus'),
            currentLetter: document.getElementById('currentLetter'),
            currentNumber: document.getElementById('currentNumber'),
            calledNumbersList: document.getElementById('calledNumbersList'),
            bingoGrid: document.getElementById('bingoGrid'),
            
            // Registration popup elements
            registrationPopup: document.getElementById('registrationPopup'),
            boardsGrid: document.getElementById('boardsGrid'),
            selectedCount: document.getElementById('selectedCount'),
            totalCost: document.getElementById('totalCost'),
            confirmSelection: document.getElementById('confirmSelection'),
            selectionTimer: document.getElementById('selectionTimer'),
            
            // Game play section elements
            gamePlaySection: document.getElementById('gamePlaySection'),
            boardsCarousel: document.getElementById('boardsCarousel'),
            currentBoard: document.getElementById('currentBoard'),
            
            // Language selector (will be created)
            languageSelector: null
        };

        // Initialize the application
        // Initialize the application
// Initialize the application
function initializeApp() {
    // Initialize Telegram integration (but don't block if not in Telegram)
    const isTelegram = initializeTelegram();
    
    // INITIALIZE BALANCE FROM SERVER - ADD THIS!
    loadBalanceFromServer().then(() => {
        console.log('üí∞ Balance loaded from server:', gameState.currentPlayer.balance);
    });

    // Initialize Service Worker
    createMainBingoBoard();
    setupEventListeners();
    updateGameStats();
    initializeMultiplayer();

    // Initialize support buttons
    supportManager.init();
    
    console.log('üéÆ ShebaBingo initialized successfully');
    
    // Start the game cycle in ALL environments
    // If in Telegram, Telegram Main Button will handle it
    // If in browser, start immediately
    if (isTelegram && Telegram.WebApp) {
        // In Telegram: Show play button, wait for click
        Telegram.WebApp.MainButton.setText("üéÆ PLAY BINGO");
        Telegram.WebApp.MainButton.onClick(() => {
            Telegram.WebApp.MainButton.hide();
            startGameCycle();
        });
        Telegram.WebApp.MainButton.show();
        console.log('ü§ñ Telegram mode: Waiting for PLAY button click');
    } else {
        // In browser: Start immediately
        startGameCycle();
        console.log('üåê Browser mode: Starting game immediately');
    }
}

// ==================== INTEGRATE WITH SERVER API ====================

// Get user ID from URL
const urlParams = new URLSearchParams(window.location.search);
const userId = urlParams.get('user') || 'demo';

// Load user balance from server API
async function loadBalanceFromServer() {
    try {
        const response = await fetch(`/api/user/${userId}/balance`);
        const data = await response.json();
        
        if (data.success) {
            // Update YOUR balance display (match your element ID)
            const balanceElement = document.getElementById('balanceValue');
            if (balanceElement) {
                balanceElement.textContent = data.balance + ' ETB';
            }
            
            // Store in global variables
            gameState.currentPlayer.balance = data.balance;
            gameState.currentPlayer.username = data.username;
            
            // Update gameState balance
            if (data.registered) {
                console.log(`Welcome ${data.username}! Balance: ${data.balance} ETB`);
            } else {
                console.log(`Guest user. Balance: ${data.balance} ETB`);
            }
            
            // Update stats
            updateGameStats();
            return true;
        }
    } catch (error) {
        console.error('Error loading balance from server:', error);
        // Fallback for local testing
        gameState.currentPlayer.balance = 1000;
        updateGameStats();
        return false;
    }
}

// Deduct game fee from server
async function deductGameFeeFromServer(amount) {
    try {
        const response = await fetch('/api/game/play', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ userId: userId, amount: amount })
        });
        
        const data = await response.json();
        if (data.success) {
            // Update local balance
            gameState.currentPlayer.balance = data.newBalance;
            
            // Update display
            const balanceElement = document.getElementById('balanceValue');
            if (balanceElement) {
                balanceElement.textContent = data.newBalance + ' ETB';
            }
            
            console.log(`üí∞ Game fee deducted: ${amount} ETB. New balance: ${data.newBalance} ETB`);
            return true;
        } else {
            alert(data.error || 'Payment failed');
            return false;
        }
    } catch (error) {
        console.error('Payment error:', error);
        alert('Network error. Please check your connection.');
        return false;
    }
}

// Add winnings to server
async function addWinningsToServer(amount) {
    try {
        const response = await fetch('/api/game/win', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ userId: userId, amount: amount })
        });
        
        const data = await response.json();
        if (data.success) {
            // Update local balance
            gameState.currentPlayer.balance = data.newBalance;
            
            // Update display
            const balanceElement = document.getElementById('balanceValue');
            if (balanceElement) {
                balanceElement.textContent = data.newBalance + ' ETB';
            }
            
            console.log(`üéâ Winnings added: ${amount} ETB. New balance: ${data.newBalance} ETB`);
            return true;
        }
    } catch (error) {
        console.error('Win error:', error);
    }
    return false;
}

// MODIFY YOUR confirmSelection() FUNCTION:
// Find this function around line 1500 and REPLACE it with:

function confirmSelection() {
    if (gameState.selectedBoards.size === 0) {
        alert(t('selectOneBoard'));
        return;
    }
    
    const totalCost = gameState.selectedBoards.size * CONFIG.BET_AMOUNT;
    
    // Check balance on SERVER
    if (totalCost > gameState.currentPlayer.balance) {
        alert(t('insufficientBalance'));
        return;
    }
    
    // Deduct from server
    deductGameFeeFromServer(totalCost).then(success => {
        if (!success) return;
        
        gameState.currentPlayer.isActive = true;
        gameState.currentPlayer.boards = createPlayerBoards();
        gameState.currentPlayer.totalPaid = totalCost;
        gameState.activePlayers.push(gameState.currentPlayer);
        
        console.log(`‚úÖ YOU selected ${gameState.selectedBoards.size} boards:`);
        gameState.selectedBoards.forEach(boardNum => {
            console.log(`   - Board #${boardNum}`);
        });
        
        // Update board display to show player's boards as selected
        gameState.selectedBoards.forEach(boardNumber => {
            const boardElements = document.querySelectorAll('.board-option');
            boardElements.forEach(element => {
                const elementBoardNum = parseInt(element.querySelector('.board-number').textContent);
                if (elementBoardNum === boardNumber) {
                    element.classList.remove('taken');
                    element.classList.add('selected');
                    element.style.background = 'linear-gradient(135deg, #2ecc71, #27ae60)';
                    element.style.color = 'white';
                    element.style.cursor = 'pointer';
                    element.style.opacity = '1';
                    element.style.border = '2px solid #27ae60';
                }
            });
        });
        
        closeRegistrationPopup();
        startShufflingPhase();
    });
}



        // Add event listener for the existing language selector in top-nav
document.addEventListener('DOMContentLoaded', function() {
    const languageSelect = document.getElementById('languageSelect');
    
    if (languageSelect) {
        // Load saved language preference
        const savedLanguage = localStorage.getItem('shebaBingoLanguage') || 'en';
        languageSelect.value = savedLanguage;
        
        // Apply saved language on load
        if (typeof setLanguage === 'function') {
            setLanguage(savedLanguage);
        }
        
        // Listen for language changes
        languageSelect.addEventListener('change', function() {
            const selectedLanguage = this.value;
            localStorage.setItem('shebaBingoLanguage', selectedLanguage);
            
            if (typeof setLanguage === 'function') {
                setLanguage(selectedLanguage);
            }
        });
    }
});
        // Service Worker Communication
        function setupServiceWorker() {
             // Empty function - does nothing
        }

        function showUpdateNotification() {
            // Show a notification that an update is available
            return;
        }
// ==================== TELEGRAM INTEGRATION ====================

// 1. Initialize Telegram Web App// Initialize Telegram Web App
// 1. Initialize Telegram Web App
function initializeTelegram() {
    // First, check if Telegram Web App SDK is available
    if (typeof window.Telegram !== 'undefined' && Telegram.WebApp) {
        const tg = Telegram.WebApp;
        
        // CRITICAL: Get user ID from Telegram OR URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const urlUserId = urlParams.get('user');
        
        // Get user data from Telegram
        const telegramUser = tg.initDataUnsafe?.user;
        
        // Determine the actual user ID (priority: Telegram > URL param > random)
        let actualUserId;
        let userName;
        let telegramName;
        
        if (telegramUser?.id) {
            // User opened from Telegram button (INSIDE Telegram)
            actualUserId = telegramUser.id;
            userName = telegramUser.first_name || 'Player';
            telegramName = telegramUser.username ? '@' + telegramUser.username : 'Telegram User';
            console.log('‚úÖ User opened from INSIDE Telegram');
        } else if (urlUserId) {
            // User opened from direct link (OUTSIDE Telegram but has user ID)
            actualUserId = urlUserId;
            userName = 'Player';
            telegramName = 'Web Player';
            console.log('‚ÑπÔ∏è User opened from direct link, ID:', urlUserId);
        } else {
            // No user ID found (testing mode)
            actualUserId = Math.floor(Math.random() * 10000) + 1;
            userName = 'Test Player';
            telegramName = 'Browser Mode';
            console.log('‚ö†Ô∏è No user ID found - using test mode');
        }
        
        // Save user ID to localStorage for API calls
        localStorage.setItem('sheba_user_id', actualUserId);
        console.log('üì± User ID saved:', actualUserId);
        
        // Configure Telegram Web App
        tg.expand(); // Expand to full screen
        tg.enableClosingConfirmation(); // Ask before closing
        
        // Set theme colors to match your game
        tg.setHeaderColor('#8b3de8');
        tg.setBackgroundColor('#d7b9f7');
        
        // Set back button behavior
        tg.BackButton.onClick(() => {
            tg.close(); // Close the app when back button pressed
        });
        
        // Show back button if in Telegram Web App
        tg.BackButton.show();
        
        // Update player info
        gameState.currentPlayer.name = userName;
        gameState.currentPlayer.telegramName = telegramName;
        gameState.currentPlayer.id = actualUserId;
       // gameState.currentPlayer.balance will be set by loadUserBalance()
        
        // Save user ID to localStorage
        localStorage.setItem('sheba_user_id', actualUserId);
        
        // Configure Telegram Web App
        tg.expand();
        tg.enableClosingConfirmation();
        tg.setHeaderColor('#8b3de8');
        tg.setBackgroundColor('#d7b9f7');
        
        // Load user balance from API
        loadUserBalance(actualUserId);
        
        console.log('‚úÖ Telegram initialized. User:', userName, 'ID:', actualUserId);
        return true;
    } else {
        console.log('‚ÑπÔ∏è Running outside Telegram (browser mode)');
        
        // Get user ID from URL parameter even in browser mode
        const urlParams = new URLSearchParams(window.location.search);
        const urlUserId = urlParams.get('user');
        
        if (urlUserId) {
            // User opened from direct link in browser
            localStorage.setItem('sheba_user_id', urlUserId);
            gameState.currentPlayer.id = urlUserId;
            console.log('üåê Browser mode with user ID:', urlUserId);
        } else {
            // Pure browser testing (no user ID)
            gameState.currentPlayer.id = Math.floor(Math.random() * 10000) + 1;
            console.log('üåê Pure browser test mode');
        }
        
        gameState.currentPlayer.name = 'Player';
        gameState.currentPlayer.telegramName = 'Browser Player';
        gameState.currentPlayer.balance = 1000; // Default test balance
        
        return false;
    }
}

// 2. Add this NEW function to load user balance
async function loadUserBalance(userId) {
    try {
        const API_BASE = window.location.origin || 'http://localhost:3000';
        const response = await fetch(`${API_BASE}/api/user/${userId}/balance`);
        const data = await response.json();
        
        if (data.success) {
            gameState.currentPlayer.balance = data.balance;
            console.log('üí∞ Balance loaded:', data.balance);
            
            // Update balance display in your game
            updateBalanceDisplay(data.balance);
        } else {
            console.warn('Failed to load balance, using default');
            gameState.currentPlayer.balance = 0;
        }
    } catch (error) {
        console.error('Error loading balance:', error);
        gameState.currentPlayer.balance = 0;
    }
}

// 3. Add this function to update balance display (you need to create this)
function updateBalanceDisplay(balance) {
    // Update wherever you show balance in your game UI
    const balanceElement = document.getElementById('playerBalance');
    if (balanceElement) {
        balanceElement.textContent = `${balance} ETB`;
    }
}

// 2. Handle Telegram Commands (optional)
function handleTelegramCommands() {
    const tg = Telegram.WebApp;
    if (!tg) return;
    
    // Get command from launch parameters
    const startParam = tg.initDataUnsafe?.start_param;
    if (startParam) {
        console.log('Start param:', startParam);
        
        switch(startParam) {
            case 'play':
                startGameCycle();
                break;
            case 'rules':
                alert("üéØ Game Rules:\n1. Select 1-3 boards\n2. Mark numbers as called\n3. Complete row/column/diagonal\n4. Claim BINGO to win!");
                break;
        }
    }
}

// 3. Send data back to Telegram Bot
function sendToTelegram(data) {
    if (window.Telegram && Telegram.WebApp) {
        Telegram.WebApp.sendData(JSON.stringify(data));
        // Telegram.WebApp.close(); // Optional: close after sending
    }
}

// 4. Update game to use Telegram when available
function updateGameForTelegram() {
    if (window.Telegram && Telegram.WebApp) {
        const tg = Telegram.WebApp;
        
        // Update game state with Telegram user
        const user = tg.initDataUnsafe?.user;
        if (user) {
            gameState.currentPlayer.telegramName = user.username ? 
                '@' + user.username : user.first_name;
        }
        
        // Send game results to bot
        gameState.winners.forEach(winner => {
            if (winner.player.id === gameState.currentPlayer.id) {
                sendToTelegram({
                    action: 'won',
                    prize: prizePerWinner,
                    board: winner.board.boardNumber,
                    timestamp: Date.now()
                });
            }
        });
    }
}

        // Create language selector
        // Keep this function but remove the CSS styling:
// Set language function - COMPREHENSIVE VERSION
function setLanguage(lang) {
    gameState.currentLanguage = lang;
    const t = TRANSLATIONS[lang];
    
    // Update game title
    const headerTitle = document.querySelector('.header h1');
    if (headerTitle) headerTitle.textContent = t.gameTitle;
    
    // Update game status
    updateGameStatus();
    
    // Update dashboard stats labels
    document.querySelectorAll('.stat-label').forEach((label, index) => {
        const labels = [t.balance, t.prize, t.players, t.bet, t.called];
        if (labels[index]) {
            label.textContent = labels[index];
        }
    });
    
    // Update BINGO header letters
    const boardLetters = document.querySelectorAll('.board-letter');
    const bingoLetters = [t.bingoB, t.bingoI, t.bingoN, t.bingoG, t.bingoO];
    boardLetters.forEach((letter, index) => {
        if (bingoLetters[index]) {
            letter.textContent = bingoLetters[index];
        }
    });
    
    // Update table headers in player boards
    const tableHeaders = document.querySelectorAll('.bingo-table th');
    tableHeaders.forEach((th, index) => {
        if (bingoLetters[index]) {
            th.textContent = bingoLetters[index];
        }
    });
    
    // Update other UI elements
    const callLabel = document.querySelector('.call-label');
    const calledNumbersLabel = document.querySelector('.called-numbers-label');
    const instructionsTitle = document.querySelector('.instructions-title');
    const instructionsContent = document.querySelector('.instructions-content');
    const playerBoardsTitle = document.querySelector('.player-boards-title');
    
    if (callLabel) callLabel.textContent = t.currentCall;
    if (calledNumbersLabel) calledNumbersLabel.textContent = t.recentlyCalled;
    if (instructionsTitle) instructionsTitle.innerHTML = `<u>${t.howToWin}</u>`;
    if (instructionsContent) instructionsContent.innerHTML = `${t.howToWin}: <br><span class="win-condition">${t.winCondition}</span>`;
    if (playerBoardsTitle) playerBoardsTitle.textContent = t.yourBoards;
    
    // Update registration popup
    const infoItems = document.querySelectorAll('.info-item span');
    if (infoItems[0]) infoItems[0].textContent = t.pricePerBoard;
    if (infoItems[1]) infoItems[1].textContent = t.maxBoards;
    if (infoItems[2]) infoItems[2].textContent = t.timeRemaining;
    
    const summaryItems = document.querySelectorAll('.summary-item span');
    if (summaryItems[0]) summaryItems[0].textContent = t.boardsSelected;
    if (summaryItems[1]) summaryItems[1].textContent = t.totalCost;
    
    const popupButtons = document.querySelectorAll('.popup-actions button');
    if (popupButtons[0]) popupButtons[0].textContent = t.cancel;
    if (popupButtons[1]) popupButtons[1].textContent = t.confirmJoin;
    
    // Update BINGO button if it exists
    const bingoBtn = document.querySelector('.bingo-btn');
    if (bingoBtn) bingoBtn.textContent = t.claimBingo;
    
    // Update Telegram Main Button if exists
    if (window.Telegram && Telegram.WebApp) {
        Telegram.WebApp.MainButton.setText(t.playBingo);
    }
    
    console.log(`üåç Language changed to: ${lang}`);
}
        // Get translation
        function t(key) {
            return TRANSLATIONS[gameState.currentLanguage][key] || TRANSLATIONS.en[key] || key;
        }

        // Game Cycle Management
        function startGameCycle() {
    // CHECK BALANCE BEFORE STARTING - ADD THIS
    if (gameState.currentPlayer.balance < CONFIG.BET_AMOUNT) {
        alert(`Insufficient balance! You need at least ${CONFIG.BET_AMOUNT} ETB to play.`);
        
        // Redirect to Telegram bot for deposit
        if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.sendData(JSON.stringify({
                action: 'need_deposit',
                amount: CONFIG.BET_AMOUNT
            }));
        } else if (userId !== 'demo') {
            window.location.href = `https://t.me/your_bot_username?start=${userId}`;
        }
        
        // Show wait message
        showWaitForNextGameMessage();
        return;
    }
    
    gameState.gamePhase = 'waiting';
    updateGameStatus();
    
    setTimeout(() => {
        startBoardSelection();
    }, 2000);
}
        function startBoardSelection() {
            gameState.gamePhase = 'selecting';
            updateGameStatus();
            
            // Reset game state for new round
            gameState.calledNumbers = [];
            gameState.currentCall = null;
            gameState.selectedBoards.clear();
            gameState.activePlayers = [];
            gameState.totalPrizePool = 0;
            gameState.ownerCommission = 0;
            gameState.winners = [];
            gameState.currentBoardIndex = 0;

            gameState.ownerCommissionTotal = 0;
            gameState.commissionHistory = [];
            gameState.withdrawalHistory = [];


            
            // Clear any existing intervals
            if (gameState.callInterval) {
                clearInterval(gameState.callInterval);
                gameState.callInterval = null;
            }
            
            // Open registration popup automatically
            openRegistrationPopup();
            
            // Start selection timer
            startSelectionTimer();
        }

        function startSelectionTimer() {
            gameState.selectionTimer = CONFIG.SELECTION_TIME;
            updateTimerDisplay();
            
            gameState.timerInterval = setInterval(() => {
                gameState.selectionTimer--;
                updateTimerDisplay();
                
                if (gameState.selectionTimer <= 0) {
                    clearInterval(gameState.timerInterval);
                    autoConfirmSelection();
                }
            }, 1000);
        }

        function startShufflingPhase() {
            gameState.gamePhase = 'shuffling';
            updateGameStatus();
            
            simulateOtherPlayersSelection();
            calculatePrizePool();
            
            // Only display boards if current player is active
            if (gameState.currentPlayer.isActive) {
                displayCurrentPlayerBoards();
            } else {
                // Current player is spectator - show watching message
                showSpectatorMessage();
            }
            
            setTimeout(() => {
                startGamePlay();
            }, CONFIG.SHUFFLE_TIME * 1000);
        }

        function startGamePlay() {
            gameState.gamePhase = 'started';
            updateGameStatus();
            
            
            // Show spectator message if current player is not active
            if (!gameState.currentPlayer.isActive) {
                showSpectatorMessage();
            }
            
            startNumberCalling();
        }

        function startNumberCalling() {
            if (gameState.callInterval) {
                clearInterval(gameState.callInterval);
            }
            
            const gameMode = CONFIG.GAME_MODES.classic; // Default to classic
            const callInterval = gameMode.callInterval || 3000;
            
            gameState.callInterval = setInterval(() => {
                if (gameState.gamePhase !== 'started') {
                    clearInterval(gameState.callInterval);
                    return;
                }
                
                if (gameState.calledNumbers.length >= 75) {
                    endGameWithNoWinner();
                    clearInterval(gameState.callInterval);
                    return;
                }
                
                callNextNumber();
                
            }, callInterval);
        }

        function callNextNumber() {
            const letters = ['B', 'I', 'N', 'G', 'O'];
            const availableLetters = letters.filter(letter => {
                const numbers = CONFIG.BINGO_NUMBERS[letter];
                return numbers.some(num => !gameState.calledNumbers.includes(num));
            });

            if (availableLetters.length === 0) return;

            const randomLetter = availableLetters[Math.floor(Math.random() * availableLetters.length)];
            const numbers = CONFIG.BINGO_NUMBERS[randomLetter];
            
            const availableNumbers = numbers.filter(num => 
                !gameState.calledNumbers.includes(num)
            );

            if (availableNumbers.length === 0) return;

            const randomNumber = availableNumbers[Math.floor(Math.random() * availableNumbers.length)];
            gameState.calledNumbers.push(randomNumber);
            gameState.currentCall = { letter: randomLetter, number: randomNumber };


            updateGameDisplay();
            
            // Simulate bot marking
            simulateBotMarking(randomNumber);
        }

        // Simulate bot marking
        function simulateBotMarking(calledNumber) {
            gameState.activePlayers.forEach(player => {
                if (player.id !== gameState.currentPlayer.id && player.isActive) {
                    const difficulty = CONFIG.BOT_DIFFICULTY[player.botDifficulty || 'medium'];
                    const shouldMark = Math.random() < difficulty.markChance;
                    
                    if (shouldMark) {
                        const reactionTime = Math.random() * 
                            (difficulty.reactionTime.max - difficulty.reactionTime.min) + 
                            difficulty.reactionTime.min;
                        
                        setTimeout(() => {
                            player.boards.forEach(board => {
                                if (!board.isEliminated && board.boardData.flat().includes(calledNumber)) {
                                    board.markedNumbers.add(calledNumber);
                                    console.log(`ü§ñ ${player.telegramName} marked ${calledNumber} (${difficulty.name})`);
                                }
                            });
                        }, reactionTime);
                    }
                }
            });
        }

        // Prize distribution with proper balance update
        function declareWinners(winners) {
            let totalBoards = 0;
            gameState.activePlayers.forEach(player => {
                totalBoards += player.boards.length;
            });
            
            const totalBet = totalBoards * CONFIG.BET_AMOUNT;
            const prizeAfterCommission = gameState.totalPrizePool;
            const prizePerWinner = Math.floor(prizeAfterCommission / winners.length);
            
            console.log(`üéØ FINAL DISTRIBUTION:`);
            console.log(`üìä Total Boards: ${totalBoards}`);
            console.log(`üíµ Total Bet: ${totalBet}`);
            console.log(`üè¶ Owner Commission: ${gameState.ownerCommission}`);
            console.log(`üèÜ Prize Pool: ${prizeAfterCommission}`);
            console.log(`üéÅ Prize per Winner: ${prizePerWinner}`);
            
            // Add prize to winners' balances
            winners.forEach(winner => {
                if (winner.player.id === gameState.currentPlayer.id) {
                    // Add prize to current player's balance
                    const oldBalance = gameState.currentPlayer.balance;
                    gameState.currentPlayer.balance += prizePerWinner;
                    console.log(`üí∞ PRIZE ADDED: ${prizePerWinner} added to your balance! (${oldBalance} ‚Üí ${gameState.currentPlayer.balance})`);
                } else {
                    // Add prize to other players' balances
                    winner.player.balance += prizePerWinner;
                }
                gameState.winners.push(winner);
            });
            
            // Update game stats immediately
updateGameStats();
showWinnersList(prizePerWinner, totalBoards);

// Send win notification to Telegram if user won
if (winners.some(w => w.player.id === gameState.currentPlayer.id)) {
    sendToTelegram({
        action: 'bingo_win',
        prize: prizePerWinner,
        boards: winners.filter(w => w.player.id === gameState.currentPlayer.id)
                      .map(w => w.board.boardNumber)
    });
}
            
            setTimeout(() => {
                endGame();
            }, 5000);
        }

        // NEW: Function to get winning numbers list
        function getWinningNumbersList(board, winningPattern) {
            const winningCells = getWinningCells(board, winningPattern);
            const winningNumbers = [];
            
            for (const cell of winningCells) {
                const number = board.boardData[cell.row][cell.col];
                if (number !== 'FREE') {
                    // Convert to B-I-N-G-O format
                    let letter = '';
                    if (number <= 15) letter = 'B';
                    else if (number <= 30) letter = 'I';
                    else if (number <= 45) letter = 'N';
                    else if (number <= 60) letter = 'G';
                    else letter = 'O';
                    
                    winningNumbers.push(`${letter}-${number}`);
                }
            }
            
            // Remove duplicates and sort
            const uniqueNumbers = [...new Set(winningNumbers)].sort((a, b) => {
                const numA = parseInt(a.split('-')[1]);
                const numB = parseInt(b.split('-')[1]);
                return numA - numB;
            });
            
            return uniqueNumbers.map(num => 
                `<span style="background: #e74c3c; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: bold;">${num}</span>`
            ).join('');
        }

        // NEW: Enhanced pattern detection with more details
        function detectWinningPattern(board) {
            // Check horizontal wins
            for (let row = 0; row < 5; row++) {
                let complete = true;
                for (let col = 0; col < 5; col++) {
                    const cellValue = board.boardData[row][col];
                    if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                        complete = false;
                        break;
                    }
                }
                if (complete) {
                    return {
                        name: `Row ${row + 1}`,
                        description: `Complete horizontal line across row ${row + 1}`,
                        type: 'horizontal',
                        row: row
                    };
                }
            }

            // Check vertical wins
            for (let col = 0; col < 5; col++) {
                let complete = true;
                for (let row = 0; row < 5; row++) {
                    const cellValue = board.boardData[row][col];
                    if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                        complete = false;
                        break;
                    }
                }
                if (complete) {
                    const columnNames = ['B', 'I', 'N', 'G', 'O'];
                    return {
                        name: `Column ${columnNames[col]}`,
                        description: `Complete vertical line down column ${columnNames[col]}`,
                        type: 'vertical',
                        col: col
                    };
                }
            }

            // Check diagonal 1 (top-left to bottom-right)
            let diag1Complete = true;
            for (let i = 0; i < 5; i++) {
                const cellValue = board.boardData[i][i];
                if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                    diag1Complete = false;
                    break;
                }
            }
            if (diag1Complete) {
                return {
                    name: "Diagonal ‚ÜòÔ∏è",
                    description: "Diagonal line from top-left to bottom-right",
                    type: 'diagonal1'
                };
            }

            // Check diagonal 2 (top-right to bottom-left)
            let diag2Complete = true;
            for (let i = 0; i < 5; i++) {
                const cellValue = board.boardData[i][4 - i];
                if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                    diag2Complete = false;
                    break;
                }
            }
            if (diag2Complete) {
                return {
                    name: "Diagonal ‚ÜôÔ∏è",
                    description: "Diagonal line from top-right to bottom-left",
                    type: 'diagonal2'
                };
            }

            // Check four corners
            const corners = [
                board.boardData[0][0], // Top-left
                board.boardData[0][4], // Top-right
                board.boardData[4][0], // Bottom-left
                board.boardData[4][4]  // Bottom-right
            ];
            const cornersComplete = corners.every(corner => 
                corner === '‚òÖ' || board.markedNumbers.has(corner)
            );
            if (cornersComplete) {
                return {
                    name: "Four Corners üéØ",
                    description: "All four corners of the board marked",
                    type: 'corners'
                };
            }

            // Check X pattern (both diagonals)
            if (diag1Complete && diag2Complete) {
                return {
                    name: "X Pattern ‚ùå",
                    description: "Both diagonal lines forming an X",
                    type: 'xpattern'
                };
            }

            // Check full house
            let fullHouse = true;
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const cellValue = board.boardData[row][col];
                    if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                        fullHouse = false;
                        break;
                    }
                }
                if (!fullHouse) break;
            }
            if (fullHouse) {
                return {
                    name: "Full House üè†",
                    description: "Every number on the board marked",
                    type: 'fullhouse'
                };
            }

            return {
                name: "Special Pattern",
                description: "Unique winning combination",
                type: 'special'
            };
        }

        // UPDATED: Enhanced board display with better pattern highlighting
 function displayWinningBoardWithPattern(board, winningPattern) {
    const winningCells = getWinningCells(board, winningPattern);
    
    let tableHTML = `
        <div style="display: inline-block; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 8px; margin: 5px 0;">
            <table style="border-collapse: collapse; font-size: 0.7rem; border: 1px solid var(--safari-gold); background: rgba(255,255,255,0.05);">
    `;
    
    // Compact header with individual letter colors
    tableHTML += '<tr>';
    
    // Individual letter colors matching BINGO columns
    const headerStyles = [
        'background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white;', // B - Blue
        'background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white;', // I - Red/Orange
        'background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: white;', // N - Green
        'background: linear-gradient(135deg, #f1c40f 0%, #f39c12 100%); color: #2c3e50;', // G - Gold/Yellow
        'background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white;'  // O - Purple
    ];
    
    const letters = ['B', 'I', 'N', 'G', 'O'];
    letters.forEach((letter, index) => {
        tableHTML += `
            <th style="
                ${headerStyles[index]}
                padding: 5px 3px;
                font-weight: bold;
                font-size: 0.65rem;
                border-bottom: 2px solid rgba(0,0,0,0.2);
                min-width: 25px;
            ">${letter}</th>
        `;
    });
    
    tableHTML += '</tr>';
    
    // Compact board cells with column-based background tints
    for (let row = 0; row < 5; row++) {
        tableHTML += '<tr>';
        for (let col = 0; col < 5; col++) {
            const cellValue = board.boardData[row][col];
            const isMarked = board.markedNumbers.has(cellValue) || cellValue === 'FREE';
            const isWinningCell = winningCells.some(cell => cell.row === row && cell.col === col);
            
            // Column-based background tints
            const columnTints = [
                'rgba(52, 152, 219, 0.1)', // B - Blue tint
                'rgba(231, 76, 60, 0.1)',   // I - Red tint
                'rgba(46, 204, 113, 0.1)',  // N - Green tint
                'rgba(241, 196, 15, 0.1)',  // G - Gold tint
                'rgba(155, 89, 182, 0.1)'   // O - Purple tint
            ];
            
            let cellStyle = '';
            
            if (isWinningCell) {
                // Winning cell - gold/yellow highlight
                cellStyle = `
                    background: linear-gradient(135deg, var(--safari-gold) 0%, #e67e22 100%);
                    color: var(--charcoal-dark);
                    border: 2px solid #e67e22;
                    font-weight: 800;
                `;
            } else if (isMarked) {
                // Marked cell - green
                cellStyle = `
                    background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
                    color: white;
                    border: 1px solid #27ae60;
                `;
            } else {
                // Regular cell - column tint
                cellStyle = `
                    background: ${columnTints[col]};
                    color: #bdc3c7;
                    border: 1px solid rgba(255,255,255,0.1);
                `;
            }
            
            // FIXED: Free space star now has green background
            tableHTML += `
                <td style="${cellStyle} padding: 4px 2px; text-align: center; font-weight: bold; min-width: 20px;">
                    ${cellValue === '‚òÖ' ? 
                        '<div style="background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; border-radius: 3px; padding: 2px; font-weight: 800; font-size: 0.6rem;">‚òÖ</div>' : 
                        cellValue}
                </td>
            `;
        }
        tableHTML += '</tr>';
    }
    
    tableHTML += '</table>';
    
    // Compact pattern indicator
    tableHTML += `
        <div style="margin-top: 5px; color: var(--safari-gold); font-size: 0.65rem; text-align: center;">
            ${winningPattern.name}
        </div>
    `;
    
    tableHTML += '</div>';
    return tableHTML;
}

        // UPDATED: Get winning cells with pattern-specific logic
        function getWinningCells(board, winningPattern) {
            const winningCells = [];
            
            switch(winningPattern.type) {
                case 'horizontal':
                    const row = winningPattern.row;
                    for (let col = 0; col < 5; col++) {
                        winningCells.push({ row, col });
                    }
                    break;
                    
                case 'vertical':
                    const col = winningPattern.col;
                    for (let row = 0; row < 5; row++) {
                        winningCells.push({ row, col });
                    }
                    break;
                    
                case 'diagonal1':
                    for (let i = 0; i < 5; i++) {
                        winningCells.push({ row: i, col: i });
                    }
                    break;
                    
                case 'diagonal2':
                    for (let i = 0; i < 5; i++) {
                        winningCells.push({ row: i, col: 4 - i });
                    }
                    break;
                    
                case 'corners':
                    winningCells.push(
                        { row: 0, col: 0 }, // Top-left
                        { row: 0, col: 4 }, // Top-right
                        { row: 4, col: 0 }, // Bottom-left
                        { row: 4, col: 4 }  // Bottom-right
                    );
                    break;
                    
                case 'xpattern':
                    for (let i = 0; i < 5; i++) {
                        winningCells.push({ row: i, col: i }); // Main diagonal
                        winningCells.push({ row: i, col: 4 - i }); // Anti-diagonal
                    }
                    break;
                    
                case 'fullhouse':
                    // All cells are winning in full house
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 5; col++) {
                            winningCells.push({ row, col });
                        }
                    }
                    break;
                    
                default:
                    // For special patterns, find all marked cells
                    for (let row = 0; row < 5; row++) {
                        for (let col = 0; col < 5; col++) {
                            const cellValue = board.boardData[row][col];
                            if (cellValue === 'FREE' || board.markedNumbers.has(cellValue)) {
                                winningCells.push({ row, col });
                            }
                        }
                    }
                    break;
            }
            
            return winningCells;
        }

        // Winner notification
        function showWinnersList(prizePerWinner, totalBoards) {
    const winnersContainer = document.createElement('div');
            winnersContainer.className = 'winners-list';
            winnersContainer.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.95);
                color: white;
                padding: 25px;
                border-radius: 15px;
                z-index: 1000;
                max-height: 80vh;
                overflow-y: auto;
                width: 90%;
                max-width: 500px;
                border: 3px solid var(--safari-gold);
                box-shadow: 0 0 30px rgba(241, 196, 15, 0.5);
                text-align: center;
                font-family: 'Poppins', sans-serif;
            `;
            
            const t = TRANSLATIONS[gameState.currentLanguage];
            
            let winnersHTML = `
                <h2 style="color: var(--safari-gold); margin-bottom: 10px; 
                font-size: 1.8rem; font-weight: 700;"># BINGO WINNERS</h2>
                
                <div style="display:none; text-align: left; margin-bottom: 20px; background: 
                rgba(255,255,255,0.1); padding: 15px; border-radius: 10px;">
                    <div style="margin-bottom: 8px;"><strong>Total Boards:</strong> ${totalBoards}</div>
                    <div style="margin-bottom: 8px;"><strong>Prize per Winner:</strong> $${prizePerWinner}</div>
                </div>
                
                <div style="display:none; color: #2ecc71; font-weight: bold; margin-bottom: 
                20px; font-size: 1.1rem;">
                    - Prize added to your balance! -
                </div>
            `;
            
            // Show current player's updated balance
            const currentPlayerWins = gameState.winners.filter(winner => winner.player.id === gameState.currentPlayer.id);
            if (currentPlayerWins.length > 0) {
                winnersHTML += `
                    <div style="display:none; background: rgba(46, 204, 113, 0.2); padding: 12px; border-radius: 8px; margin: 15px 0; border: 2px solid #2ecc71;">
                        <strong style="color: #2ecc71; font-size: 1.1rem;">Your New Balance: $${gameState.currentPlayer.balance}</strong>
                    </div>
                `;
            }
            
            winnersHTML += `<div style="height: 2px; background: var(--safari-gold); margin: 20px 0;"></div>`;
            
            gameState.winners.forEach(winner => {
                const isCurrentPlayer = winner.player.id === gameState.currentPlayer.id;
                const winningPattern = detectWinningPattern(winner.board);
                
                winnersHTML += `
                    <div style="margin: 25px 0; padding: 20px; background: rgba(255,255,255,0.05); border-radius: 12px; border: 2px solid ${isCurrentPlayer ? 'var(--safari-gold)' : 'rgba(255,255,255,0.2)'};">
                        <div style="color: ${isCurrentPlayer ? 'var(--safari-gold)' : '#ccc'}; font-weight: bold; margin-bottom: 10px; font-size: 1.2rem;">
                            ${winner.player.telegramName} ${isCurrentPlayer ? t.you : ''}
                        </div>
                        <div style="color: #ccc; margin-bottom: 15px; font-size: 0.9rem;">
                            Board #${winner.board.boardNumber}
                        </div>
                        
                        <!-- Prize Information -->
                        <div style="display:none; color: #2ecc71; font-weight: bold; margin-bottom: 15px; font-size: 1rem;">
                            üèÜ <strong>Prize:</strong> $${prizePerWinner}
                        </div>
                        
                        <!-- Winning Pattern Information -->
                        <div style="margin: 15px 0;">
                            <div style=" display:none; color: var(--safari-gold); font-size: 0.9rem; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px;">
                                üéØ Winning Pattern: ${winningPattern.name}
                            </div>
                            <div style="display:none; color: #ccc; font-size: 0.8rem; margin-bottom: 15px; font-style: italic;">
                                ${winningPattern.description}
                            </div>
                        </div>
                        
                        <!-- Show actual winning board with highlighted pattern -->
                        <div style="margin-top: 15px;">
                            ${displayWinningBoardWithPattern(winner.board, winningPattern)}
                        </div>
                        
                        <!-- Show winning numbers list -->
                        <div style="margin-top: 15px;">
                            <div style="color: var(--safari-gold); font-size: 0.8rem; margin-bottom: 8px;">
                                üìã Winning Numbers:
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 5px; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px;">
                                ${getWinningNumbersList(winner.board, winningPattern)}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            winnersHTML += `
                <div style="margin-top: 25px; color: #3498db; font-size: 0.9rem; font-style: italic;">
                    ${t.nextGame}
                </div>
            `;
            
            winnersContainer.innerHTML = winnersHTML;
            document.body.appendChild(winnersContainer);
            
            setTimeout(() => {
                if (winnersContainer.parentNode) {
                    winnersContainer.parentNode.removeChild(winnersContainer);
                }
            }, 10000);
}

// ==================== DEPOSIT FUNCTION ====================

// Go to deposit (opens Telegram bot)
function goToDeposit() {
    const t = TRANSLATIONS[gameState.currentLanguage];
    
    if (window.Telegram && Telegram.WebApp) {
        // In Telegram Web App - send data to bot
        Telegram.WebApp.sendData(JSON.stringify({
            action: 'deposit',
            userId: userId,
            amount: CONFIG.BET_AMOUNT,
            timestamp: Date.now()
        }));
        
        // Show message
        alert(t('redirectingToDeposit') || 'Opening deposit page in Telegram...');
        
    } else if (userId && userId !== 'demo') {
        // In browser - open Telegram bot with start parameter
        window.location.href = `https://t.me/your_bot_username?start=${userId}_deposit`;
        
    } else {
        // No user ID - show instructions
        alert(t('openFromTelegram') || 'Please open this game from Telegram bot to deposit.');
    }
}

        function endGameWithNoWinner() {
            gameState.gamePhase = 'finished';
            updateGameStatus();
            
            const noWinnerMsg = document.createElement('div');
            noWinnerMsg.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 20px;
                border-radius: 10px;
                z-index: 1000;
                text-align: center;
                border: 2px solid #e74c3c;
            `;
            noWinnerMsg.innerHTML = `<h3 style="color: #e74c3c;">No Winners This Round!</h3><p>Prize carried over to next game</p>`;
            document.body.appendChild(noWinnerMsg);
            
            setTimeout(() => {
                if (noWinnerMsg.parentNode) {
                    noWinnerMsg.parentNode.removeChild(noWinnerMsg);
                }
                endGame();
            }, 5000);
        }

        function endGame() {
            gameState.gamePhase = 'waiting';
            updateGameStatus();
            elements.gamePlaySection.style.display = 'none';
            
            
            if (gameState.callInterval) {
                clearInterval(gameState.callInterval);
                gameState.callInterval = null;
            }
            
            // Reset player boards but keep their updated balances
            gameState.activePlayers.forEach(player => {
                player.boards = [];
                player.isActive = false;
            });
            
            setTimeout(() => {
                startGameCycle();
            }, 2000);
        }

        // Create main bingo board display
        function createMainBingoBoard() {
            elements.bingoGrid.innerHTML = '';
            const letters = ['B', 'I', 'N', 'G', 'O'];
            
            for (let row = 0; row < 15; row++) {
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'bingo-cell';
                    
                    const letter = letters[col];
                    const range = CONFIG.BINGO_NUMBERS[letter];
                    const number = range[row];
                    
                    cell.textContent = number;
                    cell.setAttribute('data-letter', letter);
                    cell.setAttribute('data-number', number);
                    
                    elements.bingoGrid.appendChild(cell);
                }
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            elements.confirmSelection.addEventListener('click', confirmSelection);
        }

        // BINGO claim function
function claimBingo() {
    const t = TRANSLATIONS[gameState.currentLanguage];
    
    if (!gameState.currentPlayer.isActive || gameState.gamePhase !== 'started') {
        alert(t('cannotClaimBingo'));
        return;
    }
    
    const winningBoards = [];
    const eliminatedBoards = [];
    let hasAnyWinningPattern = false;
    
    gameState.currentPlayer.boards.forEach((board, index) => {
        if (!board.isEliminated) {
            const winningPatterns = getAllWinningPatterns(board);
            
            if (winningPatterns.length > 0) {
                winningBoards.push({ board, boardIndex: index });
                hasAnyWinningPattern = true;
                console.log(`‚úÖ WIN: Board ${board.boardNumber} has winning pattern`);
            } else {
                eliminatedBoards.push({ board, boardIndex: index, reason: 'fraud_no_pattern' });
                board.isEliminated = true;
                console.log(`üö® FRAUD: Board ${board.boardNumber} eliminated - no winning pattern`);
                
                const uncalledMarks = checkUncalledMarks(board);
                if (uncalledMarks.length > 0) {
                    console.log(`   üîç Found ${uncalledMarks.length} uncalled marks: ${uncalledMarks.join(', ')}`);
                }
            }
        }
    });
    
    // If player has NO winning patterns on ANY board, eliminate them completely
    if (!hasAnyWinningPattern) {
        gameState.currentPlayer.isActive = false;
        console.log(`üö®üö® PLAYER ELIMINATED FOR FRAUD: No winning patterns found on any board`);
        
        // Show fraud elimination message (TRANSLATED)
        showEliminationMessage(t('fraudClaimed'));
        
        elements.gamePlaySection.style.display = 'none';
        updateGameStatus();
        
        return;
    }
    
    if (winningBoards.length > 0) {
        gameState.gamePhase = 'checking';
        updateGameStatus();
        
        winningBoards.forEach(win => {
            win.board.isWinner = true;
        });
        
        setTimeout(() => {
            const winners = winningBoards.map(win => ({
                player: gameState.currentPlayer,
                board: win.board,
                boardIndex: win.boardIndex
            }));
// CALCULATE WIN AMOUNT
        const prizePerWinner = Math.floor(gameState.totalPrizePool / winners.length);
        
        // ADD WINNINGS TO SERVER
        winners.forEach(winner => {
            if (winner.player.id === gameState.currentPlayer.id) {
                addWinningsToServer(prizePerWinner);
            }
        });
            declareWinners(winners);
        }, CONFIG.CHECKING_TIME * 1000);
    }
}

function getAllWinningPatterns(board) {
    const patterns = [];
    
    // Check rows
    for (let row = 0; row < 5; row++) {
        let complete = true;
        for (let col = 0; col < 5; col++) {
            const cellValue = board.boardData[row][col];
            if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                complete = false;
                break;
            }
        }
        if (complete) patterns.push({ type: 'row', index: row });
    }
    
    // Check columns
    for (let col = 0; col < 5; col++) {
        let complete = true;
        for (let row = 0; row < 5; row++) {
            const cellValue = board.boardData[row][col];
            if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                complete = false;
                break;
            }
        }
        if (complete) patterns.push({ type: 'column', index: col });
    }
    
    // Check diagonals
    let diag1Complete = true;
    let diag2Complete = true;
    for (let i = 0; i < 5; i++) {
        const cell1 = board.boardData[i][i];
        const cell2 = board.boardData[i][4 - i];
        
        if (cell1 !== '‚òÖ' && !board.markedNumbers.has(cell1)) {
            diag1Complete = false;
        }
        if (cell2 !== '‚òÖ' && !board.markedNumbers.has(cell2)) {
            diag2Complete = false;
        }
    }
    if (diag1Complete) patterns.push({ type: 'diagonal', name: 'main' });
    if (diag2Complete) patterns.push({ type: 'diagonal', name: 'anti' });
    
    // Check four corners
    const corners = [
        board.boardData[0][0],
        board.boardData[0][4],
        board.boardData[4][0],
        board.boardData[4][4]
    ];
    const cornersComplete = corners.every(corner => 
        corner === '‚òÖ' || board.markedNumbers.has(corner)
    );
    if (cornersComplete) patterns.push({ type: 'corners' });
    
    // Check full house (all numbers marked)
    let fullHouse = true;
    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 5; col++) {
            const cellValue = board.boardData[row][col];
            if (cellValue !== '‚òÖ' && !board.markedNumbers.has(cellValue)) {
                fullHouse = false;
                break;
            }
        }
        if (!fullHouse) break;
    }
    if (fullHouse) patterns.push({ type: 'fullhouse' });
    
    return patterns;
}

function checkUncalledMarks(board) {
    const uncalled = [];
    
    board.markedNumbers.forEach(markedNumber => {
        if (!gameState.calledNumbers.includes(markedNumber)) {
            uncalled.push(markedNumber);
        }
    });
    
    return uncalled;
}

function checkForFraud(board) {
    // Only check fraud if there's NO winning pattern
    
    let fraudDetected = false;
    const uncalledMarks = checkUncalledMarks(board);
    
    if (uncalledMarks.length > 0) {
        // Check if uncalled marks are part of a winning pattern
        // If they're NOT part of any pattern, it's fraud
        
        const patternsWon = getAllWinningPatterns(board);
        
        if (patternsWon.length === 0) {
            // No winning patterns but has uncalled marks = FRAUD
            fraudDetected = true;
            console.log(`üö® FRAUD DETECTED: ${uncalledMarks.length} uncalled marks with no winning pattern`);
        } else {
            // Has winning pattern(s) - uncalled marks are forgiven
            console.log(`‚ö†Ô∏è ${uncalledMarks.length} uncalled marks forgiven (winning pattern exists)`);
            fraudDetected = false;
        }
    }
    
    return fraudDetected;
}


     function showEliminationMessage(message) {
    const eliminationMsg = document.createElement('div');
    eliminationMsg.style.cssText = `
        position: fixed;
        top: 20%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(231, 76, 60, 0.95);
        color: white;
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        text-align: center;
        border: 2px solid #c0392b;
        font-weight: bold;
        font-size: 1.1rem;
        max-width: 90%;
        word-wrap: break-word;
    `;
    eliminationMsg.innerHTML = `<strong>${message}</strong>`;
    document.body.appendChild(eliminationMsg);
    
    setTimeout(() => {
        if (eliminationMsg.parentNode) {
            eliminationMsg.parentNode.removeChild(eliminationMsg);
        }
    }, 5000);
}
  // Initialize multiplayer system
        function initializeMultiplayer() {
            gameState.allPlayers = [gameState.currentPlayer];
            
            const telegramNames = ['@ethio_player', '@bingo_lover', '@game_master', '@lucky_winner', '@quick_draw'];
            
            telegramNames.forEach((name, index) => {
                const player = {
                    id: index + 2,
                    name: 'Player ' + (index + 2),
                    telegramName: name,
                    balance: 0,
                    boards: [],
                    isActive: false,
                    totalPaid: 0,
                    // Assign random bot difficulty
                    botDifficulty: Object.keys(CONFIG.BOT_DIFFICULTY)[Math.floor(Math.random() * Object.keys(CONFIG.BOT_DIFFICULTY).length)]
                };
                gameState.allPlayers.push(player);
            });
        }

        // Update game status display
        function updateGameStatus() {
    const statusTexts = {
        'waiting': t('waiting'),
        'selecting': t('selecting'),
        'shuffling': t('shuffling'),
        'started': gameState.currentPlayer.isActive ? t('started') : t('waiting'),
        'checking': t('checking'),
        'finished': t('finished')
    };
    
    elements.gameStatus.textContent = statusTexts[gameState.gamePhase] || t('waiting');
    elements.gameStatus.className = 'status-badge game-' + gameState.gamePhase;
}

        // Update all game statistics with proper balance display
        function updateGameStats() {
            // Update balance display immediately
            elements.balanceValue.textContent = gameState.currentPlayer.balance;
            elements.prizeValue.textContent = gameState.totalPrizePool;
            
            let totalBoards = 0;
            gameState.activePlayers.forEach(player => {
                totalBoards += player.boards.length;
            });
            elements.playersValue.textContent = totalBoards;
            
            elements.calledCount.textContent = gameState.calledNumbers.length;
            
            console.log(`üìä Stats Update: Balance: $${gameState.currentPlayer.balance}, Total Boards: ${totalBoards}, Prize: ${gameState.totalPrizePool}`);
        }

        function calculatePrizePool() {
            let totalBoards = 0;
            gameState.activePlayers.forEach(player => {
                totalBoards += player.boards.length;
            });
            
            const totalBet = totalBoards * CONFIG.BET_AMOUNT;
            gameState.ownerCommission = Math.floor(totalBet * gameState.commissionRate);
            gameState.totalPrizePool = totalBet - gameState.ownerCommission;
            gameState.totalCommissionEarned += gameState.ownerCommission;
            
            console.log(`üéØ PRIZE CALCULATION:`);
            console.log(`üìä Total Boards: ${totalBoards}`);
            console.log(`üí∞ Bet per Board: ${CONFIG.BET_AMOUNT}`);
            console.log(`üíµ Total Bet: ${totalBoards} √ó ${CONFIG.BET_AMOUNT} = ${totalBet}`);
            console.log(`üè¶ Owner Commission (20%): ${gameState.ownerCommission}`);
            console.log(`üèÜ Prize Pool (80%): ${gameState.totalPrizePool}`);
            
            updateGameStats();
        }

        // Registration Popup Functions
        function openRegistrationPopup() {
            elements.registrationPopup.style.display = 'flex';
            generateBoardOptions();
            updateSelectionInfo();
        }

        function closeRegistrationPopup() {
            elements.registrationPopup.style.display = 'none';
            clearInterval(gameState.timerInterval);
        }

        function updateTimerDisplay() {
            elements.selectionTimer.textContent = `${gameState.selectionTimer} ${t('seconds') || 'seconds'}`;
            
            if (gameState.selectionTimer <= 10) {
                elements.selectionTimer.style.color = '#e74c3c';
                elements.selectionTimer.classList.add('timer-warning');
            } else {
                elements.selectionTimer.style.color = '';
                elements.selectionTimer.classList.remove('timer-warning');
            }
        }

        function generateBoardOptions() {
    elements.boardsGrid.innerHTML = '';
    
    gameState.availableBoards.forEach(boardNumber => {
        const boardElement = document.createElement('div');
        boardElement.className = 'board-option';
        boardElement.innerHTML = `<div class="board-number">${boardNumber}</div>`;
        
        // Check if board is taken by OTHER players (not current player)
        const isTaken = isBoardTaken(boardNumber);
        
        if (isTaken) {
            boardElement.classList.add('taken');
            boardElement.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)'; // Red gradient
            boardElement.style.color = 'white';
            boardElement.style.cursor = 'not-allowed';
            boardElement.style.opacity = '0.7';
            boardElement.style.border = '2px solid #e74c3c';
            
            // Add a taken indicator
            const takenIndicator = document.createElement('div');
            takenIndicator.className = 'taken-indicator';
            takenIndicator.innerHTML = '‚úó';
            takenIndicator.style.cssText = `
                position: absolute;
                top: 2px;
                right: 2px;
                color: white;
                font-size: 10px;
                background: rgba(0,0,0,0.5);
                border-radius: 50%;
                width: 15px;
                height: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            boardElement.style.position = 'relative';
            boardElement.appendChild(takenIndicator);
        }
        
        boardElement.addEventListener('click', () => toggleBoardSelection(boardNumber, boardElement));
        elements.boardsGrid.appendChild(boardElement);
    });
}

       function isBoardTaken(boardNumber) {
    // Check if taken by any active player
    for (let player of gameState.activePlayers) {
        if (player.boards.some(board => board.boardNumber === boardNumber)) {
            return true;
        }
    }
    
    // Also check if current player has already selected this board
    if (gameState.selectedBoards.has(boardNumber)) {
        return false; // Not "taken" since it's selected by current player
    }
    
    return false;
}

        function toggleBoardSelection(boardNumber, element) {
    // Check if board is taken by OTHER players
    if (isBoardTaken(boardNumber) && !gameState.selectedBoards.has(boardNumber)) {
        // Show alert AND visual feedback
        element.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            element.style.animation = '';
        }, 500);
        
        alert(t('boardTaken'));
        return;
    }
    
    if (element.classList.contains('taken')) {
        // Already handled above, but just in case
        return;
    }
    
    if (gameState.selectedBoards.has(boardNumber)) {
        // Deselect the board
        gameState.selectedBoards.delete(boardNumber);
        element.classList.remove('selected');
        element.style.background = '';
        element.style.color = '';
        element.style.border = '';
    } else if (gameState.selectedBoards.size < CONFIG.MAX_BOARDS_PER_PLAYER) {
        // Select the board
        gameState.selectedBoards.add(boardNumber);
        element.classList.add('selected');
        element.style.background = 'linear-gradient(135deg, #2ecc71, #27ae60)';
        element.style.color = 'white';
        element.style.border = '2px solid #27ae60';
    } else {
        // Maximum boards reached
        element.style.animation = 'shake 0.5s ease';
        setTimeout(() => {
            element.style.animation = '';
        }, 500);
        
        alert(t('maxBoardsReached'));
        return;
    }
    
    updateSelectionInfo();
    validateForm();
}

        function updateSelectionInfo() {
            const selectedCount = gameState.selectedBoards.size;
            const totalCost = selectedCount * CONFIG.BET_AMOUNT;
            
            elements.selectedCount.textContent = selectedCount;
            elements.totalCost.textContent = totalCost;
        }

        function validateForm() {
            const boardsValid = gameState.selectedBoards.size > 0;
            const hasEnoughBalance = (gameState.selectedBoards.size * CONFIG.BET_AMOUNT) <= gameState.currentPlayer.balance;
            elements.confirmSelection.disabled = !(boardsValid && hasEnoughBalance);
        }

        function autoConfirmSelection() {
            // Player didn't select any boards - show wait message
            closeRegistrationPopup();
            showWaitForNextGameMessage();
            
            // Continue with other players who might have selected boards
            setTimeout(() => {
                if (gameState.activePlayers.length > 0) {
                    // Other players selected boards, continue the game
                    startShufflingPhase();
                } else {
                    // No players at all selected boards, end this round
                    console.log('‚è≥ No players selected boards, ending round');
                    endGame();
                }
            }, 1000);
        }

        // Show wait message
        function showWaitForNextGameMessage() {
    elements.gamePlaySection.style.display = 'block';
    elements.boardsCarousel.innerHTML = '';
    elements.currentBoard.innerHTML = '';
    
    const waitMessage = document.createElement('div');
    waitMessage.className = 'wait-message';
    waitMessage.style.cssText = `
        text-align: center;
        padding: 30px 20px;
        color: var(--deep-purple);
        font-size: 1.2rem;
        font-weight: bold;
        background: white;
        border-radius: 10px;
        margin: 15px 0;
        border: 2px solid var(--deep-purple);
        box-shadow: 0 4px 12px rgba(139, 61, 232, 0.2);
    `;
    
    const t = TRANSLATIONS[gameState.currentLanguage];
    waitMessage.innerHTML = `
        <div style="margin-bottom: 15px; font-size: 1.4rem;">‚è≥</div>
        <div style="color: var(--deep-purple); margin-bottom: 10px;">
            ${t.waiting}
        </div>
        
        <div style="font-size: 0.8rem; color: #aaa; margin-top: 15px;">
            Next game starts automatically
        </div>
    `;
    
    elements.currentBoard.appendChild(waitMessage);
    
    // Update game status to show player is not active
    gameState.currentPlayer.isActive = false;
    updateGameStatus();
    
    console.log('‚è≥ Player skipped board selection - waiting for next game');
}

        // Show spectator message
       function showSpectatorMessage() {
    elements.gamePlaySection.style.display = 'block';
    elements.boardsCarousel.innerHTML = '';
    elements.currentBoard.innerHTML = '';
    
    const waitMessage = document.createElement('div');
    waitMessage.className = 'wait-message';
    waitMessage.style.cssText = `
        text-align: center;
        padding: 30px 20px;
        color: var(--deep-purple);
        font-size: 1.2rem;
        font-weight: bold;
        background: white;
        border-radius: 10px;
        margin: 15px 0;
        border: 2px solid var(--deep-purple);
        box-shadow: 0 4px 12px rgba(139, 61, 232, 0.2);
    `;
    
    const t = TRANSLATIONS[gameState.currentLanguage];
    const timeLeft = gameState.calledNumbers.length < 75 ? 
        `(~${Math.max(1, Math.floor((75 - gameState.calledNumbers.length) * 3 / 60))} min)` : 
        '';
    
    waitMessage.innerHTML = `
        <div style="margin-bottom: 15px; font-size: 1.4rem;">‚è≥</div>
        <div style="color: var(--deep-purple); margin-bottom: 10px;">
            ${t.waiting}
        </div>
       
        <div style="font-size: 0.8rem; color: #aaa; margin-top: 15px;">
            Next game starts automatically
        </div>
    `;
    
    elements.currentBoard.appendChild(waitMessage);
    
    console.log(`‚è≥ Player waiting for next game.`);
}

        // Balance deduction when buying boards
       function confirmSelection() {
    if (gameState.selectedBoards.size === 0) {
        alert(t('selectOneBoard'));
        return;
    }
    
    const totalCost = gameState.selectedBoards.size * CONFIG.BET_AMOUNT;
    if (totalCost > gameState.currentPlayer.balance) {
        alert(t('insufficientBalance'));
        return;
    }
    
    // Deduct cost from balance
    const oldBalance = gameState.currentPlayer.balance;
    gameState.currentPlayer.balance -= totalCost;
    console.log(`üí∞ Balance deducted: ${totalCost} (${oldBalance} ‚Üí ${gameState.currentPlayer.balance})`);
    
    gameState.currentPlayer.isActive = true;
    gameState.currentPlayer.boards = createPlayerBoards();
    gameState.currentPlayer.totalPaid = totalCost;
    gameState.activePlayers.push(gameState.currentPlayer);
    
    console.log(`‚úÖ YOU selected ${gameState.selectedBoards.size} boards:`);
    gameState.selectedBoards.forEach(boardNum => {
        console.log(`   - Board #${boardNum}`);
    });
    
    // Update board display to show player's boards as selected (not taken)
    gameState.selectedBoards.forEach(boardNumber => {
        const boardElements = document.querySelectorAll('.board-option');
        boardElements.forEach(element => {
            const elementBoardNum = parseInt(element.querySelector('.board-number').textContent);
            if (elementBoardNum === boardNumber) {
                element.classList.remove('taken');
                element.classList.add('selected');
                element.style.background = 'linear-gradient(135deg, #2ecc71, #27ae60)';
                element.style.color = 'white';
                element.style.cursor = 'pointer';
                element.style.opacity = '1';
                element.style.border = '2px solid #27ae60';
            }
        });
    });
    
    // Update balance display immediately
    updateGameStats();
    
    closeRegistrationPopup();
    startShufflingPhase();
}

        function createPlayerBoards() {
            const playerBoards = [];
            gameState.selectedBoards.forEach(boardNumber => {
                playerBoards.push({
                    boardNumber: boardNumber,
                    boardData: generateBingoBoard(),
                    markedNumbers: new Set(),
                    isWinner: false,
                    isEliminated: false
                });
            });
            return playerBoards;
        }

       function simulateOtherPlayersSelection() {
    console.log('ü§ñ SIMULATING OTHER PLAYERS...');
    
    for (let i = 1; i < gameState.allPlayers.length; i++) {
        const player = gameState.allPlayers[i];
        const willPlay = Math.random() > 0.3; // 70% chance bots will play
        
        if (willPlay && player.balance >= CONFIG.BET_AMOUNT) {
            player.isActive = true;
            const numBoards = Math.floor(Math.random() * 3) + 1; // 1-3 boards randomly
            
            // Deduct cost from bot players too
            player.balance -= numBoards * CONFIG.BET_AMOUNT;
            
            player.boards = generateSimulatedBoards(numBoards);
            player.totalPaid = numBoards * CONFIG.BET_AMOUNT;
            
            gameState.activePlayers.push(player);
            
            console.log(`ü§ñ ${player.telegramName} selected ${numBoards} board(s) - Difficulty: ${player.botDifficulty}`);
            
            // Update the board display to show these boards as taken
            player.boards.forEach(board => {
                const boardElements = document.querySelectorAll('.board-option');
                boardElements.forEach(element => {
                    const elementBoardNum = parseInt(element.querySelector('.board-number').textContent);
                    if (elementBoardNum === board.boardNumber) {
                        element.classList.add('taken');
                        element.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                        element.style.color = 'white';
                        element.style.cursor = 'not-allowed';
                        element.style.opacity = '0.7';
                        element.style.border = '2px solid #e74c3c';
                    }
                });
            });
        }
    }
    
    console.log(`üéÆ Total active players: ${gameState.activePlayers.length}`);
    updateGameStats();
}
function updateBoardDisplay() {
    const boardElements = document.querySelectorAll('.board-option');
    
    boardElements.forEach(element => {
        const boardNumber = parseInt(element.querySelector('.board-number').textContent);
        const isTaken = isBoardTaken(boardNumber);
        const isSelected = gameState.selectedBoards.has(boardNumber);
        
        // Reset styles
        element.classList.remove('taken', 'selected');
        element.style.background = '';
        element.style.color = '';
        element.style.cursor = '';
        element.style.opacity = '';
        element.style.border = '';
        
        // Remove existing taken indicator
        const existingIndicator = element.querySelector('.taken-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }
        
        if (isTaken && !isSelected) {
            // Board taken by other player
            element.classList.add('taken');
            element.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
            element.style.color = 'white';
            element.style.cursor = 'not-allowed';
            element.style.opacity = '0.7';
            element.style.border = '2px solid #e74c3c';
            
            const takenIndicator = document.createElement('div');
            takenIndicator.className = 'taken-indicator';
            takenIndicator.innerHTML = '‚úó';
            element.style.position = 'relative';
            element.appendChild(takenIndicator);
            
        } else if (isSelected) {
            // Board selected by current player
            element.classList.add('selected');
            element.style.background = 'linear-gradient(135deg, #2ecc71, #27ae60)';
            element.style.color = 'white';
            element.style.border = '2px solid #27ae60';
        }
    });
}
        function generateSimulatedBoards(numBoards) {
            const boards = [];
            
            for (let i = 0; i < numBoards; i++) {
                let boardNumber;
                let attempts = 0;
                do {
                    boardNumber = Math.floor(Math.random() * CONFIG.TOTAL_BOARDS) + 1;
                    attempts++;
                    if (attempts > 100) break;
                } while (isBoardTaken(boardNumber));
                
                if (attempts <= 100) {
                    boards.push({
                        boardNumber: boardNumber,
                        boardData: generateBingoBoard(),
                        markedNumbers: new Set(),
                        isWinner: false,
                        isEliminated: false
                    });
                }
            }
            
            return boards;
        }

        // Bingo Board Generation
        function generateBingoBoard() {
            const B = shuffleArray([...CONFIG.BINGO_NUMBERS['B']]).slice(0, 5).sort((a, b) => a - b);
            const I = shuffleArray([...CONFIG.BINGO_NUMBERS['I']]).slice(0, 5).sort((a, b) => a - b);
            const N = shuffleArray([...CONFIG.BINGO_NUMBERS['N']]).slice(0, 4).sort((a, b) => a - b);
            const G = shuffleArray([...CONFIG.BINGO_NUMBERS['G']]).slice(0, 5).sort((a, b) => a - b);
            const O = shuffleArray([...CONFIG.BINGO_NUMBERS['O']]).slice(0, 5).sort((a, b) => a - b);
            
            const board = [];
            let nIndex = 0;
            
            for (let row = 0; row < 5; row++) {
                const rowData = [
                    B[row],
                    I[row],
                    row === 2 ? '‚òÖ' : N[nIndex++],
                    G[row],
                    O[row]
                ];
                board.push(rowData);
            }
            
            return board;
        }


function updateBoardDisplay() {
    const boardElements = document.querySelectorAll('.board-option');
    
    boardElements.forEach(element => {
        const boardNumber = parseInt(element.querySelector('.board-number').textContent);
        const isTaken = isBoardTaken(boardNumber);
        const isSelected = gameState.selectedBoards.has(boardNumber);
        
        // Reset styles
        element.classList.remove('taken', 'selected');
        element.style.background = '';
        element.style.color = '';
        element.style.cursor = '';
        element.style.opacity = '';
        element.style.border = '';
        
        // Remove existing taken indicator
        const existingIndicator = element.querySelector('.taken-indicator');
        if (existingIndicator) {
            existingIndicator.remove();
        }
        
        if (isTaken && !isSelected) {
            // Board taken by other player
            element.classList.add('taken');
            element.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
            element.style.color = 'white';
            element.style.cursor = 'not-allowed';
            element.style.opacity = '0.7';
            element.style.border = '2px solid #e74c3c';
            
            const takenIndicator = document.createElement('div');
            takenIndicator.className = 'taken-indicator';
            takenIndicator.innerHTML = '‚úó';
            element.style.position = 'relative';
            element.appendChild(takenIndicator);
            
        } else if (isSelected) {
            // Board selected by current player
            element.classList.add('selected');
            element.style.background = 'linear-gradient(135deg, #2ecc71, #27ae60)';
            element.style.color = 'white';
            element.style.border = '2px solid #27ae60';
        }
    });
}

        function shuffleArray(array) {
            return array.sort(() => Math.random() - 0.5);
        }

        function updateGameDisplay() {
            if (gameState.currentCall) {
                elements.currentLetter.textContent = gameState.currentCall.letter;
                elements.currentNumber.textContent = gameState.currentCall.number;
            }
            
            updateCalledNumbersList();
            updateMainBoardColors();
            updateGameStats();
        }
// 2. TABLE LAYOUT FIX FUNCTION (place it here)
function ensureTableLayout() {
    const containers = document.querySelectorAll('.bingo-table-container');
    
    containers.forEach(container => {
        // Force right padding
        container.style.paddingLeft = '0';
        container.style.paddingRight = '10px';
        
        // Ensure container width is correct
        const parentWidth = container.parentElement.offsetWidth;
        container.style.width = '100%';
        container.style.maxWidth = '100%';
        
        // Check table width
        const table = container.querySelector('.bingo-table');
        if (table) {
            // Ensure table fills container
            table.style.width = '100%';
            table.style.minWidth = '100%';
            
            // Calculate column widths for 5 columns
            const containerWidth = container.offsetWidth - 10; // Subtract right padding
            const colWidth = (containerWidth / 5) + 'px';
            
            // Apply equal width to all headers and cells
            const headers = table.querySelectorAll('th');
            const cells = table.querySelectorAll('td');
            
            headers.forEach(header => {
                header.style.minWidth = colWidth;
                header.style.maxWidth = colWidth;
            });
            
            // First row cells
            const firstRowCells = table.querySelectorAll('tr:first-child td');
            firstRowCells.forEach(cell => {
                cell.style.minWidth = colWidth;
                cell.style.maxWidth = colWidth;
            });
        }
    });
}
// 3. OTHER GAME FUNCTIONS (after table fix)

function updateCalledNumbersList() {
    const container = elements.calledNumbersList;
    container.innerHTML = '';
    
    // Get ONLY last 5 called numbers
    const recentCalls = gameState.calledNumbers.slice(-5);
    
    if (recentCalls.length === 0) {
        container.innerHTML = '<div style="color:#aaa;font-size:0.55rem;text-align:center;padding:4px;">- - -</div>';
        return;
    }
    
    // Check if mobile
    const isMobile = window.innerWidth <= 500;
    const isVerySmall = window.innerWidth <= 360; // Extra small phones
    
    // NO REVERSING - Keep natural order (oldest to newest)
    recentCalls.forEach((number, index) => {
        let letter = '';
        let color = '';
        let textColor = 'white';
        
        // Simple color mapping
        if (number <= 15) {
            letter = 'B';
            color = '#3498db'; // Blue
        } else if (number <= 30) {
            letter = 'I';
            color = '#e74c3c'; // Red
        } else if (number <= 45) {
            letter = 'N';
            color = '#2ecc71'; // Green
        } else if (number <= 60) {
            letter = 'G';
            color = '#f1c40f'; // Yellow
            textColor = '#2c3e50'; // Dark text for yellow
        } else {
            letter = 'O';
            color = '#9b59b6'; // Purple
        }

        const callElement = document.createElement('div');
        callElement.className = 'called-number-item';
        callElement.dataset.index = index;
        
        // Check if this is the most recent (last in array)
        const isMostRecent = index === recentCalls.length - 1;
        
        // DETERMINE SIZES BASED ON SCREEN
        let fontSize, itemWidth, itemHeight, padding, borderRadius;
        
        if (isVerySmall) {
            // EXTRA SMALL PHONES (‚â§360px)
            fontSize = '0.5rem';
            itemWidth = '28px';
            itemHeight = '18px';
            padding = '1px';
            borderRadius = '2px';
        } else if (isMobile) {
            // REGULAR MOBILE (‚â§500px)
            fontSize = '0.55rem';
            itemWidth = '30px';
            itemHeight = '20px';
            padding = '1px 2px';
            borderRadius = '2px';
        } else {
            // DESKTOP (>500px)
            fontSize = '0.65rem';
            itemWidth = '36px';
            itemHeight = '24px';
            padding = '2px 3px';
            borderRadius = '3px';
        }
        
        // Apply styles
        callElement.style.cssText = `
            background: ${color};
            color: ${textColor};
            border-radius: ${borderRadius};
            padding: ${padding};
            font-size: ${fontSize};
            width: ${itemWidth};
            height: ${itemHeight};
            text-align: center;
            cursor: pointer;
            font-weight: 700;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: ${isMostRecent ? '0 0 0 1px white, 0 1px 3px rgba(0,0,0,0.3)' : '0 1px 2px rgba(0,0,0,0.2)'};
            position: relative;
            overflow: hidden;
            margin: 0 ${isVerySmall ? '1px' : (isMobile ? '1.5px' : '2px')} 0 0;
            line-height: 1;
            transform: ${isMostRecent ? 'scale(1.05)' : 'scale(1)'};
            z-index: ${isMostRecent ? '5' : '1'};
            animation: ${isMostRecent ? 'slideInFromRight 0.2s ease-out' : 'none'};
            transition: all 0.2s ease;
        `;
        
        // Create inner HTML with appropriate font sizes
        const letterSize = isVerySmall ? '0.6rem' : (isMobile ? '0.65rem' : '0.7rem');
        const hyphenSize = isVerySmall ? '0.5rem' : (isMobile ? '0.55rem' : '0.6rem');
        const numberSize = isVerySmall ? '0.7rem' : (isMobile ? '0.75rem' : '0.8rem');
        
        callElement.innerHTML = `
            <span style="font-weight:600; font-size:${letterSize};">${letter}</span>
            <span style="margin: 0 0.5px; font-size:${hyphenSize};">-</span>
            <span style="font-weight:800; font-size:${numberSize};">${number}</span>
        `;
        
        // Check marking status
        let isMarkedOnAny = false;
        let isUnmarkedOnAny = false;
        
        if (gameState.currentPlayer.isActive) {
            gameState.currentPlayer.boards.forEach(board => {
                if (!board.isEliminated && board.markedNumbers.has(number)) {
                    isMarkedOnAny = true;
                } else if (!board.isEliminated) {
                    isUnmarkedOnAny = true;
                }
            });
        }
        
        // Add marking indicator (very small)
        if (isMarkedOnAny && !isUnmarkedOnAny) {
            const indicator = document.createElement('div');
            const dotSize = isVerySmall ? '4px' : (isMobile ? '5px' : '6px');
            indicator.style.cssText = `
                position: absolute;
                top: 1px;
                right: 1px;
                width: ${dotSize};
                height: ${dotSize};
                background: #27ae60;
                border-radius: 50%;
                border: 1px solid white;
                z-index: 1;
            `;
            callElement.appendChild(indicator);
        }
        
        // Add click handler
        callElement.addEventListener('click', function() {
            markNumberOnPlayerBoards(number, this);
            
            // Quick feedback
            this.style.opacity = '0.7';
            this.style.transform = 'scale(0.95)';
            setTimeout(() => {
                this.style.opacity = '1';
                this.style.transform = isMostRecent ? 'scale(1.05)' : 'scale(1)';
            }, 150);
        });
        
        // Add hover effect (desktop only)
        if (!isMobile) {
            callElement.addEventListener('mouseenter', function() {
                const currentScale = isMostRecent ? 1.05 : 1;
                this.style.transform = `scale(${currentScale * 1.05})`;
                this.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)';
            });
            
            callElement.addEventListener('mouseleave', function() {
                this.style.transform = isMostRecent ? 'scale(1.05)' : 'scale(1)';
                this.style.boxShadow = isMostRecent ? 
                    '0 0 0 1px white, 0 1px 3px rgba(0,0,0,0.3)' : 
                    '0 1px 2px rgba(0,0,0,0.2)';
            });
        }
        
        container.appendChild(callElement);
    });
    
    // Calculate container size based on screen
    let containerHeight, totalWidth;
if (isVerySmall) {
    containerHeight = '20px';
    const itemWidth = 28; // pixels
    const gap = 1; // pixels
    totalWidth = (itemWidth * recentCalls.length) + (gap * (recentCalls.length - 1));
} else if (isMobile) {
    containerHeight = '22px';
    const itemWidth = 30; // pixels
    const gap = 1.5; // pixels
    totalWidth = (itemWidth * recentCalls.length) + (gap * (recentCalls.length - 1));
} else {
    containerHeight = '26px';
    const itemWidth = 36; // pixels
    const gap = 2; // pixels
    totalWidth = (itemWidth * recentCalls.length) + (gap * (recentCalls.length - 1));
}
    // Apply container styles
    container.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        min-width: ${totalWidth}px;
        max-width: 100%;
        height: ${containerHeight};
        padding: 0;
        overflow: visible;
        flex-direction: row;
        gap: ${isVerySmall ? '1px' : (isMobile ? '1.5px' : '2px')};
        background: transparent;
        margin: 0 auto;
    `;
    
    // Add CSS animation
    const styleId = 'called-numbers-animation-' + Date.now();
    const style = document.createElement('style');
    style.id = styleId;
    style.textContent = `
        @keyframes slideInFromRight {
            from {
                transform: translateX(10px) scale(0.9);
                opacity: 0;
            }
            to {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }
    `;
    
    // Remove old style if exists
    const oldStyle = document.getElementById('called-numbers-animation');
    if (oldStyle) oldStyle.remove();
    
    // Add new style
    document.head.appendChild(style);
}

function markNumberOnPlayerBoards(number, callElement) {
            if (!gameState.currentPlayer.isActive || gameState.gamePhase !== 'started') {
                console.log('Cannot mark number: Game not active or wrong phase');
                return;
            }
            
            let marked = false;
            let unmarked = false;
            
            gameState.currentPlayer.boards.forEach(board => {
                if (!board.isEliminated) {
                    if (board.markedNumbers.has(number)) {
                        board.markedNumbers.delete(number);
                        unmarked = true;
                        console.log(`‚ùå Unmarked number ${number} on board ${board.boardNumber}`);
                    } else {
                        board.markedNumbers.add(number);
                        marked = true;
                        console.log(`‚úÖ Marked number ${number} on board ${board.boardNumber}`);
                    }
                }
            });
            
            if (callElement) {
                if (marked && !unmarked) {
                    callElement.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
                    callElement.style.color = 'white';
                    callElement.classList.add('marked');
                    callElement.classList.remove('mixed');
                } else if (unmarked && !marked) {
                    callElement.style.background = 'rgba(255, 255, 255, 0.2)';
                    callElement.style.color = 'var(--safari-gold)';
                    callElement.classList.remove('marked', 'mixed');
                } else if (marked && unmarked) {
                    callElement.style.background = 'linear-gradient(135deg, #3498db, #2980b9)';
                    callElement.style.color = 'white';
                    callElement.classList.add('mixed');
                    callElement.classList.remove('marked');
                }
                
                callElement.style.transform = 'scale(1.1)';
                callElement.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.3)';
                
                setTimeout(() => {
                    callElement.style.transform = 'scale(1)';
                    callElement.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
                }, 300);
            }
            
            displayCurrentPlayerBoards(gameState.currentBoardIndex);
            console.log('‚ÑπÔ∏è Number marked/unmarked. Game continues until player claims BINGO.');
        }

        function updateMainBoardColors() {
            const cells = document.querySelectorAll('.bingo-cell');
            
            cells.forEach(cell => {
                const cellNumber = parseInt(cell.getAttribute('data-number'));
                
                cell.classList.remove('current-called', 'previously-called');
                
                if (gameState.calledNumbers.includes(cellNumber) && 
                    cellNumber !== (gameState.currentCall?.number || 0)) {
                    cell.classList.add('previously-called');
                }
                
                if (cellNumber === (gameState.currentCall?.number || 0)) {
                    cell.classList.add('current-called');
                }
            });
        }

        // Player Board Management
        function displayCurrentPlayerBoards(forceBoardIndex = null) {
            if (!gameState.currentPlayer.isActive) return;
            
            elements.gamePlaySection.style.display = 'block';
            elements.boardsCarousel.innerHTML = '';
            elements.currentBoard.innerHTML = '';

            const activeBoards = gameState.currentPlayer.boards.filter(board => !board.isEliminated);
            
            if (activeBoards.length === 0) {
                elements.gamePlaySection.style.display = 'none';
                return;
            }

            if (forceBoardIndex !== null) {
                gameState.currentBoardIndex = forceBoardIndex;
            }
            
            if (gameState.currentBoardIndex >= activeBoards.length) {
                gameState.currentBoardIndex = 0;
            }

            activeBoards.forEach((board, index) => {
                const miniature = document.createElement('div');
                miniature.className = `board-miniature ${index === gameState.currentBoardIndex ? 'active' : ''}`;
                miniature.innerHTML = `<div>${t('#').split(' ')[0]} ${board.boardNumber}</div>`;
                miniature.addEventListener('click', () => switchBoard(index));
                elements.boardsCarousel.appendChild(miniature);
            });

            if (activeBoards.length > 0) {
                displayBoard(gameState.currentBoardIndex);
            }
        }

        function switchBoard(boardIndex) {
            gameState.currentBoardIndex = boardIndex;
            
            document.querySelectorAll('.board-miniature').forEach((mini, index) => {
                mini.classList.toggle('active', index === boardIndex);
            });
            
            const activeBoards = gameState.currentPlayer.boards.filter(board => !board.isEliminated);
            if (activeBoards.length > boardIndex) {
                displayBoard(boardIndex);
            }
        }

       function displayBoard(boardIndex) {
    elements.currentBoard.innerHTML = '';

    const activeBoards = gameState.currentPlayer.boards.filter(board => !board.isEliminated);
    const board = activeBoards[boardIndex];

    const table = document.createElement('table');
    table.className = 'bingo-table';
    
    const headerRow = document.createElement('tr');
    
    // Define letters with their color classes
    const letters = [
        { letter: 'B', colorClass: 'b' },
        { letter: 'I', colorClass: 'i' },
        { letter: 'N', colorClass: 'n' },
        { letter: 'G', colorClass: 'g' },
        { letter: 'O', colorClass: 'o' }
    ];
    
    // Create header cells with individual colors
    letters.forEach(item => {
        const th = document.createElement('th');
        th.textContent = item.letter;
        th.className = item.colorClass;  // ‚Üê ADD THIS LINE
        headerRow.appendChild(th);
    });
    
    table.appendChild(headerRow);
    
    // ... rest of the code stays the same
    for (let row = 0; row < 5; row++) {
        const tr = document.createElement('tr');
        
        for (let col = 0; col < 5; col++) {
            const td = document.createElement('td');
            const cellValue = board.boardData[row][col];
            
            td.textContent = cellValue;
            
            if (cellValue === '‚òÖ') {
    td.classList.add('free-space');
    td.innerHTML = '<div style="background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin: 0 auto; font-weight: 800; font-size: 0.8rem; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">‚òÖ</div>';
} else if (board.markedNumbers.has(cellValue)) {
                td.classList.add('marked');
                td.style.cursor = 'pointer';
                td.addEventListener('click', () => {
                    markNumberOnPlayerBoards(cellValue, null);
                });
            } else {
                td.style.cursor = 'pointer';
                td.addEventListener('click', () => {
                    markNumberOnPlayerBoards(cellValue, null);
                });
            }
            
            tr.appendChild(td);
        }
        table.appendChild(tr);
    }
    
    elements.currentBoard.appendChild(table);
    
    const bingoButton = document.createElement('button');
    bingoButton.className = 'bingo-btn';
    bingoButton.textContent = t('claimBingo');
    bingoButton.style.marginTop = '10px';
    bingoButton.style.width = '100%';
    bingoButton.addEventListener('click', claimBingo);
    elements.currentBoard.appendChild(bingoButton);
}

        // Win Checking
        function checkBoardWin(board) {
    const patterns = getAllWinningPatterns(board);
    return patterns.length > 0;
}

        // Support Manager
        const supportManager = {
            init: function() {
                this.createSupportButtons();
            },
            
            createSupportButtons: function() {
                // Create support container
                const supportContainer = document.createElement('div');
                supportContainer.id = 'supportContainer';
                supportContainer.style.cssText = `
                    position: fixed;
                    bottom: 30px;
                    right: 10px;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    z-index: 1000;
                    font-family: 'Poppins', sans-serif;
                `;
                
                // Telegram Support Button
                const telegramBtn = document.createElement('div');
                telegramBtn.className = 'support-btn';
                telegramBtn.style.cssText = `
                    width: 30px;
                    height: 30px;
                    background: #0088cc;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    transition: all 0.3s ease;
                `;
                
                telegramBtn.innerHTML = `
                    <a href="https://t.me/YourUsername" target="_blank">
                        <img src="https://cdn-icons-png.flaticon.com/512/2111/2111646.png"
                             alt="Telegram" width="30">
                    </a>
                `;
                telegramBtn.title = 'Contact us on Telegram';
                
                // FAQ/Help Button
                const helpBtn = document.createElement('div');
                helpBtn.className = 'support-btn';
                helpBtn.style.cssText = `
                    width: 30px;
                    height: 30px;
                    background: var(--safari-gold);
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    transition: all 0.3s ease;
                `;
                helpBtn.innerHTML = '‚ùì';
                helpBtn.title = 'Quick Help & FAQ';
                
                // Call Support Button
                const callBtn = document.createElement('div');
                callBtn.className = 'support-btn';
                callBtn.style.cssText = `
                    width: 30px;
                    height: 30px;                    
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    transition: all 0.3s ease;
                `;
                callBtn.innerHTML = 'üìû';
                callBtn.title = 'Call Support';
                
                // Add hover effects
                [telegramBtn, callBtn, helpBtn].forEach(btn => {
                    btn.addEventListener('mouseenter', () => {
                        btn.style.transform = 'scale(1.1)';
                        btn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.4)';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.transform = 'scale(1)';
                        btn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
                    });
                });
                
                // Event listeners
                helpBtn.addEventListener('click', () => this.toggleSupportButtons(helpBtn, telegramBtn, callBtn));
                telegramBtn.addEventListener('click', () => this.openTelegramSupport());
                callBtn.addEventListener('click', () => this.showCallSupport());
                
                // Add buttons in correct order - question mark LAST (at bottom)
                supportContainer.appendChild(callBtn);      // Will be at TOP
                supportContainer.appendChild(telegramBtn);  // Will be in MIDDLE  
                supportContainer.appendChild(helpBtn);      // Will be at BOTTOM (visible)
                
                document.body.appendChild(supportContainer);
            },
            
            toggleSupportButtons: function(helpBtn, telegramBtn, callBtn) {
                // Check if other buttons are visible
                const telegramVisible = telegramBtn.style.display !== 'none';
                const callVisible = callBtn.style.display !== 'none';
                
                if (telegramVisible || callVisible) {
                    // Hide other buttons (collapse)
                    telegramBtn.style.display = 'none';
                    callBtn.style.display = 'none';
                    helpBtn.innerHTML = '‚ùì';
                    helpBtn.title = 'Show Support Options';
                } else {
                    // Show other buttons (expand)
                    telegramBtn.style.display = 'flex';
                    callBtn.style.display = 'flex';
                    helpBtn.innerHTML = '‚ùì';
                    helpBtn.title = 'Close Support Menu';
                    // Show quick help immediately when expanding
                    this.showQuickHelp();
                }
            },
            
            openTelegramSupport: function() {
                // Open Telegram support
                const telegramUrl = 'https://t.me/ShebaBingoSupport';
                window.open(telegramUrl, '_blank');
                
                // Show confirmation message
                this.showSupportMessage('Opening Telegram support...', 'info');
            },
            
            showCallSupport: function() {
                // Show call support information
                const phoneNumber = '+251945343143';
                const callMessage = `
                    <div style="text-align: center;">
                        <h3 style="color: var(--safari-gold); margin-bottom: 10px;">üìû Call Support</h3>
                        <p style="margin-bottom: 15px; font-size: 1.1rem;">For immediate assistance, call our support team:</p>
                        <div style="background: rgba(39, 174, 96, 0.2); padding: 15px; border-radius: 10px; margin: 10px 0;">
                            <strong style="color: #27ae60; font-size: 1.3rem;">${phoneNumber}</strong>
                        </div>
                        <p style="font-size: 0.9rem; color: #ccc;">Available 24/7 for game support and account issues</p>
                    </div>
                `;
                
                this.showSupportModal('Call Support', callMessage);
            },
            
            showQuickHelp: function() {
                // Quick help and FAQ
                const helpContent = `
                    <div style="max-height: 400px; overflow-y: auto;">
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--safari-gold); margin-bottom: 10px;">üéÆ How to Play</h4>
                            <ul style="text-align: left; color: #ccc; font-size: 0.9rem;">
                                <li>Select 1-3 boards during registration</li>
                                <li>Mark numbers as they are called</li>
                                <li>Complete a row, column, or diagonal to win</li>
                                <li>Click "CLAIM BINGO" when you have a winning pattern</li>
                                <li>Each board costs 10 ETB to play</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--safari-gold); margin-bottom: 10px;">üí∞ Payments</h4>
                            <ul style="text-align: left; color: #ccc; font-size: 0.9rem;">
                                <li>Minimum deposit: 10 ETB</li>
                                <li>Minimum withdrawal: 50 ETB</li>
                                <li>Supported: Telebirr, CBE, BOA</li>
                                <li>Withdrawals processed within 5 Minutes</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h4 style="color: var(--safari-gold); margin-bottom: 10px;">üèÜ Prizes</h4>
                            <ul style="text-align: left; color: #ccc; font-size: 0.9rem;">
                            <li>Prizes automatically added to balance</li>
                            <li>Multiple winners split the prize</li>
                               
                            </ul>
                        </div>
                        
                        <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(52, 152, 219, 0.2); border-radius: 10px;">
                            <p style="margin: 0; color: #3498db; font-size: 0.9rem;">
                                Need more help? Contact us via Telegram or phone!
                            </p>
                        </div>
                    </div>
                `;
                
                this.showSupportModal('Quick Help & FAQ', helpContent);
            },
            
            showSupportModal: function(title, content) {
                // Remove existing modal if any
                const existingModal = document.getElementById('supportModal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                // Create modal
                const modal = document.createElement('div');
                modal.id = 'supportModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1001;
                    font-family: 'Poppins', sans-serif;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
                        padding: 30px;
                        border-radius: 15px;
                        max-width: 500px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                        border: 2px solid var(--safari-gold);
                    ">
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 20px;
                            border-bottom: 1px solid var(--safari-gold);
                            padding-bottom: 10px;
                        ">
                            <h2 style="color: var(--safari-gold); margin: 0; font-size: 1.5rem;">${title}</h2>
                            <button onclick="this.closest('#supportModal').remove()" style="
                                background: none;
                                border: none;
                                color: var(--safari-gold);
                                font-size: 1.5rem;
                                cursor: pointer;
                                padding: 0;
                                width: 30px;
                                height: 30px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">‚úï</button>
                        </div>
                        <div>${content}</div>
                    </div>
                `;
                
                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                document.body.appendChild(modal);
            },
            
            showSupportMessage: function(message, type) {
                // Create toast message
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'info' ? '#3498db' : '#27ae60'};
                    color: white;
                    padding: 15px 25px;
                    border-radius: 10px;
                    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
                    z-index: 1002;
                    font-family: 'Poppins', sans-serif;
                    font-weight: 500;
                `;
                toast.textContent = message;
                
                document.body.appendChild(toast);
                
                // Remove toast after 3 seconds
                setTimeout(() => {
                    toast.remove();
                }, 3000);
            },
            
            closeSupportMenu: function() {
                const supportContainer = document.getElementById('supportContainer');
                if (supportContainer) {
                    const buttons = supportContainer.querySelectorAll('.support-btn');
                    buttons.forEach((btn, index) => {
                        if (index > 0) { // Keep first button (help button) visible
                            btn.style.display = 'none';
                        }
                    });
                    
                    // Reset help button to question mark
                    const helpBtn = buttons[0];
                    if (helpBtn) {
                        helpBtn.innerHTML = '‚ùì';
                        helpBtn.title = 'Show Support Options';
                    }
                }
            }
        };

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
        window.closeRegistrationPopup = closeRegistrationPopup;
    </script>
</body>
</html>

